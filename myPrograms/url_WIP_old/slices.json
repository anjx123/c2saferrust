[
  {
    "func_defid": "DefId(0:46 ~ oxidate_out[187d]::decode_percent)",
    "span": "src/main.rs:595:1: 626:2 (#0)",
    "pieces": [
      "src/main.rs:595:1: 626:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 33,
    "source": "unsafe extern \"C\" fn decode_percent(mut s: *mut libc::c_char) -> *mut libc::c_char {\n    let mut in_0 = s;\n    let mut out = s;\n    while *in_0 != 0 {\n        if *in_0 as libc::c_int == '%' as i32 {\n            in_0 = in_0.offset(1);\n            let high = unhex(in_0);\n            if high < 0 as libc::c_int || *in_0 as libc::c_int == '\\0' as i32 {\n                return 0 as *mut libc::c_char;\n            }\n            in_0 = in_0.offset(1);\n            let low = unhex(in_0);\n            if low < 0 as libc::c_int || *in_0 as libc::c_int == '\\0' as i32 {\n                return 0 as *mut libc::c_char;\n            }\n            *out = (high as libc::c_uint)\n                .wrapping_mul(16 as libc::c_uint)\n                .wrapping_add(low as libc::c_uint) as libc::c_char;\n            out = out.offset(1);\n            out;\n            in_0 = in_0.offset(1);\n            in_0;\n        } else {\n            let fresh0 = in_0;\n            in_0 = in_0.offset(1);\n            let fresh1 = out;\n            out = out.offset(1);\n            *fresh1 = *fresh0;\n        }\n    }\n    *out = '\\0' as i32 as libc::c_char;\n    return s;\n}",
    "calls": [
      {
        "caller": "DefId(0:73 ~ oxidate_out[187d]::url_parse)",
        "span": "src/main.rs:1150:5: 1151:71 (#0)",
        "source": "let decoded = decode_percent(p_str)\n        .expect(\"Invalid percent encoding in fragment (call site 1)\");"
      },
      {
        "caller": "DefId(0:73 ~ oxidate_out[187d]::url_parse)",
        "span": "src/main.rs:1099:5: 1100:68 (#0)",
        "source": "let decoded = decode_percent(query_substr)\n        .expect(\"Invalid percent encoding in query (call site 4)\");"
      },
      {
        "caller": "DefId(0:73 ~ oxidate_out[187d]::url_parse)",
        "span": "src/main.rs:1049:5: 1050:67 (#0)",
        "source": "let decoded = decode_percent(p_str)\n        .expect(\"Invalid percent encoding in path (call site 5)\");"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/main.rs:23:1: 23:14 (#0)",
        "source": "use std::str;"
      },
      {
        "span": "src/main.rs:27:22: 27:29 (#0)",
        "source": "CString"
      },
      {
        "span": "src/main.rs:30:1: 30:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/main.rs:25:1: 25:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/main.rs:27:1: 27:31 (#0)",
        "source": "use std::ffi::{CStr, CString};"
      },
      {
        "span": "src/main.rs:28:1: 28:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/main.rs:22:1: 22:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/main.rs:27:16: 27:20 (#0)",
        "source": "CStr"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:53 ~ oxidate_out[187d]::url_is_ssh)",
    "span": "src/main.rs:1230:1: 1232:2 (#0)",
    "pieces": [
      "src/main.rs:1230:1: 1232:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "pub unsafe extern \"C\" fn url_is_ssh(mut str: *const libc::c_char) -> bool {\n    if 0 as libc::c_int == strcmp(str, b\"ssh\\0\" as *const u8 as *const libc::c_char)\n        || 0 as libc::c_int == strcmp(str, b\"git\\0\" as *const u8 as *const libc::c_char)\n    {\n        return 1 as libc::c_int != 0;\n    }\n    return 0 as libc::c_int != 0;\n}",
    "calls": [
      {
        "caller": "DefId(0:73 ~ oxidate_out[187d]::url_parse)",
        "span": "src/main.rs:775:1: 775:35 (#0)",
        "source": "let is_ssh = url_is_ssh(protocol);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/main.rs:25:1: 25:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/main.rs:23:1: 23:14 (#0)",
        "source": "use std::str;"
      },
      {
        "span": "src/main.rs:27:22: 27:29 (#0)",
        "source": "CString"
      },
      {
        "span": "src/main.rs:30:1: 30:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/main.rs:27:16: 27:20 (#0)",
        "source": "CStr"
      },
      {
        "span": "src/main.rs:27:1: 27:31 (#0)",
        "source": "use std::ffi::{CStr, CString};"
      },
      {
        "span": "src/main.rs:28:1: 28:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/main.rs:22:1: 22:16 (#0)",
        "source": "use std::slice;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:54 ~ oxidate_out[187d]::url_get_scheme)",
    "span": "src/main.rs:1235:1: 1247:2 (#0)",
    "pieces": [
      "src/main.rs:1235:1: 1247:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 14,
    "source": "pub unsafe extern \"C\" fn url_get_scheme(\n    mut url: *const libc::c_char,\n) -> *mut libc::c_char {\n    let mut protocol = malloc(32 as libc::c_int as libc::c_ulong) as *mut libc::c_char;\n    if protocol.is_null() {\n        return 0 as *mut libc::c_char;\n    }\n    sscanf(url, b\"%[^://]\\0\" as *const u8 as *const libc::c_char, protocol);\n    if url_is_protocol(protocol) {\n        return protocol;\n    }\n    free(protocol as *mut libc::c_void);\n    return 0 as *mut libc::c_char;\n}",
    "calls": [
      {
        "caller": "DefId(0:57 ~ oxidate_out[187d]::url_get_protocol)",
        "span": "src/main.rs:121:54: 123:2 (#0)",
        "source": "{\n    url_get_scheme(url)\n}"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/main.rs:28:1: 28:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/main.rs:25:1: 25:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/main.rs:27:16: 27:20 (#0)",
        "source": "CStr"
      },
      {
        "span": "src/main.rs:23:1: 23:14 (#0)",
        "source": "use std::str;"
      },
      {
        "span": "src/main.rs:27:1: 27:31 (#0)",
        "source": "use std::ffi::{CStr, CString};"
      },
      {
        "span": "src/main.rs:27:22: 27:29 (#0)",
        "source": "CString"
      },
      {
        "span": "src/main.rs:30:1: 30:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/main.rs:22:1: 22:16 (#0)",
        "source": "use std::slice;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:65 ~ oxidate_out[187d]::url_free)",
    "span": "src/main.rs:1523:1: 1527:2 (#0)",
    "pieces": [
      "src/main.rs:1523:1: 1527:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "pub unsafe extern \"C\" fn url_free(mut data: *mut url_data_t) {\n    if data.is_null() {\n        return;\n    }\n    free((*data).whole_url as *mut libc::c_void);\n    free((*data).query as *mut libc::c_void);\n    free(data as *mut libc::c_void);\n}",
    "calls": [
      {
        "caller": "DefId(0:84 ~ oxidate_out[187d]::url_get_hostname)",
        "span": "src/main.rs:1290:5: 1293:6 (#0)",
        "source": "unsafe {\n        // Convert the raw pointer into an Option<Box<url_data_t>> as expected by url_free.\n        url_free(Some(Box::from_raw(data_ptr)))\n    }"
      },
      {
        "caller": "DefId(0:83 ~ oxidate_out[187d]::url_get_userinfo)",
        "span": "src/main.rs:1267:9: 1267:36 (#0)",
        "source": "url_free(Some(boxed_data));"
      },
      {
        "caller": "DefId(0:88 ~ oxidate_out[187d]::url_get_path)",
        "span": "src/main.rs:1369:5: 1369:30 (#0)",
        "source": "url_free(Some(data_box));"
      },
      {
        "caller": "DefId(0:73 ~ oxidate_out[187d]::url_parse)",
        "span": "src/main.rs:1198:1: 1198:20 (#0)",
        "source": "url_free(data_box);"
      },
      {
        "caller": "DefId(0:91 ~ oxidate_out[187d]::url_get_port)",
        "span": "src/main.rs:1441:5: 1441:38 (#0)",
        "source": "unsafe { url_free(Some(parsed)) }"
      },
      {
        "caller": "DefId(0:86 ~ oxidate_out[187d]::url_get_pathname)",
        "span": "src/main.rs:1345:5: 1345:30 (#0)",
        "source": "url_free(Some(data_box));"
      },
      {
        "caller": "DefId(0:85 ~ oxidate_out[187d]::url_get_host)",
        "span": "src/main.rs:1320:5: 1320:55 (#0)",
        "source": "unsafe { url_free(Some(Box::from_raw(data_ptr))) }"
      },
      {
        "caller": "DefId(0:90 ~ oxidate_out[187d]::url_get_fragment)",
        "span": "src/main.rs:1419:5: 1419:26 (#0)",
        "source": "url_free(boxed_data);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/main.rs:27:1: 27:31 (#0)",
        "source": "use std::ffi::{CStr, CString};"
      },
      {
        "span": "src/main.rs:27:16: 27:20 (#0)",
        "source": "CStr"
      },
      {
        "span": "src/main.rs:22:1: 22:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/main.rs:28:1: 28:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/main.rs:23:1: 23:14 (#0)",
        "source": "use std::str;"
      },
      {
        "span": "src/main.rs:30:1: 30:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/main.rs:27:22: 27:29 (#0)",
        "source": "CString"
      },
      {
        "span": "src/main.rs:25:1: 25:14 (#0)",
        "source": "use std::ptr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:47 ~ oxidate_out[187d]::scan_part)",
    "span": "src/main.rs:628:1: 651:2 (#0)",
    "pieces": [
      "src/main.rs:628:1: 651:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 24,
    "source": "unsafe extern \"C\" fn scan_part(\n    mut start: *mut libc::c_char,\n    mut category: Category,\n    mut delimiter1: libc::c_char,\n    mut delimiter2: libc::c_char,\n) -> *mut libc::c_char {\n    let mut p = start;\n    loop {\n        if *p as libc::c_int == '\\0' as i32\n            || *p as libc::c_int == delimiter1 as libc::c_int\n            || *p as libc::c_int == delimiter2 as libc::c_int\n        {\n            return p;\n        }\n        if char_cat[*p as libc::c_uchar as usize] as libc::c_uint\n            & category as libc::c_uint != 0\n        {\n            p = p.offset(1);\n            p;\n        } else {\n            return 0 as *mut libc::c_char\n        }\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:73 ~ oxidate_out[187d]::url_parse)",
        "span": "src/main.rs:1057:45: 1062:47 (#0)",
        "source": "let mut query_end = scan_part(\n                                                p,\n                                                Query,\n                                                '#' as i32 as libc::c_char,\n                                                '\\0' as i32 as libc::c_char,\n                                            );"
      },
      {
        "caller": "DefId(0:73 ~ oxidate_out[187d]::url_parse)",
        "span": "src/main.rs:1080:53: 1085:55 (#0)",
        "source": "let mut fragment_end = scan_part(\n                                                        query_end.offset(1 as libc::c_int as isize),\n                                                        Fragment,\n                                                        '\\0' as i32 as libc::c_char,\n                                                        '\\0' as i32 as libc::c_char,\n                                                    );"
      },
      {
        "caller": "DefId(0:73 ~ oxidate_out[187d]::url_parse)",
        "span": "src/main.rs:862:33: 867:35 (#0)",
        "source": "hostname_end = scan_part(\n                                    p,\n                                    IPv6Char,\n                                    ']' as i32 as libc::c_char,\n                                    '\\0' as i32 as libc::c_char,\n                                );"
      },
      {
        "caller": "DefId(0:73 ~ oxidate_out[187d]::url_parse)",
        "span": "src/main.rs:927:33: 933:35 (#0)",
        "source": "hostname_end = scan_part(\n                                    p,\n                                    (Unreserved as libc::c_int | SubDelim as libc::c_int)\n                                        as Category,\n                                    ':' as i32 as libc::c_char,\n                                    '/' as i32 as libc::c_char,\n                                );"
      },
      {
        "caller": "DefId(0:73 ~ oxidate_out[187d]::url_parse)",
        "span": "src/main.rs:1134:45: 1139:47 (#0)",
        "source": "let mut fragment_end_0 = scan_part(\n                                                p,\n                                                Fragment,\n                                                '\\0' as i32 as libc::c_char,\n                                                '\\0' as i32 as libc::c_char,\n                                            );"
      },
      {
        "caller": "DefId(0:73 ~ oxidate_out[187d]::url_parse)",
        "span": "src/main.rs:759:9: 759:70 (#0)",
        "source": "protocol_end = scan_part(p, Scheme, b':' as i8, b'\\0' as i8);"
      },
      {
        "caller": "DefId(0:73 ~ oxidate_out[187d]::url_parse)",
        "span": "src/main.rs:1020:37: 1025:39 (#0)",
        "source": "path_end = scan_part(\n                                        p,\n                                        PCharSlash,\n                                        '?' as i32 as libc::c_char,\n                                        '#' as i32 as libc::c_char,\n                                    );"
      },
      {
        "caller": "DefId(0:73 ~ oxidate_out[187d]::url_parse)",
        "span": "src/main.rs:834:25: 839:27 (#0)",
        "source": "userinfo_end = scan_part(\n                            p,\n                            Userinfo,\n                            '@' as i32 as libc::c_char,\n                            '\\0' as i32 as libc::c_char,\n                        );"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/main.rs:25:1: 25:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/main.rs:23:1: 23:14 (#0)",
        "source": "use std::str;"
      },
      {
        "span": "src/main.rs:27:16: 27:20 (#0)",
        "source": "CStr"
      },
      {
        "span": "src/main.rs:27:22: 27:29 (#0)",
        "source": "CString"
      },
      {
        "span": "src/main.rs:22:1: 22:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/main.rs:30:1: 30:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/main.rs:28:1: 28:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/main.rs:27:1: 27:31 (#0)",
        "source": "use std::ffi::{CStr, CString};"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:49 ~ oxidate_out[187d]::parse_query_string)",
    "span": "src/main.rs:663:1: 713:2 (#0)",
    "pieces": [
      "src/main.rs:663:1: 713:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 80,
    "source": "unsafe extern \"C\" fn parse_query_string(\n    mut begin: *mut libc::c_char,\n    mut end: *mut libc::c_char,\n) -> *mut url_key_value {\n    let mut current_block: u64;\n    let mut elements = 1 as libc::c_int as libc::c_uint;\n    let mut p: *const libc::c_char = begin;\n    while p != end as *const libc::c_char {\n        if *p as libc::c_int == '&' as i32 || *p as libc::c_int == ';' as i32 {\n            elements = elements.wrapping_add(1);\n            elements;\n        }\n        p = p.offset(1);\n        p;\n    }\n    let mut kv = calloc(\n        elements.wrapping_add(1 as libc::c_int as libc::c_uint) as libc::c_ulong,\n        ::core::mem::size_of::<url_key_value>() as libc::c_ulong,\n    ) as *mut url_key_value;\n    if kv.is_null() {\n        return 0 as *mut url_key_value;\n    }\n    let mut p_0 = begin;\n    let mut element = 0 as libc::c_int as libc::c_uint;\n    loop {\n        if !(element <= elements && p_0 < end) {\n            current_block = 11584701595673473500;\n            break;\n        }\n        let mut key = p_0;\n        let mut kv_end = scan_part(\n            p_0,\n            Query,\n            '&' as i32 as libc::c_char,\n            ';' as i32 as libc::c_char,\n        );\n        if kv_end.is_null() {\n            fprintf(\n                stderr,\n                b\"ERROR %s Line %u! p=\\xC2\\xAB%s\\xC2\\xBB\\n\\0\" as *const u8\n                    as *const libc::c_char,\n                b\"/workspace/programs/url/url.c\\0\" as *const u8 as *const libc::c_char,\n                153 as libc::c_int,\n                p_0,\n            );\n            current_block = 7272095228866324518;\n            break;\n        } else {\n            *kv_end = '\\0' as i32 as libc::c_char;\n            let mut key_end = scan_part(\n                p_0,\n                Query,\n                '=' as i32 as libc::c_char,\n                '\\0' as i32 as libc::c_char,\n            );\n            let has_value = *key_end as libc::c_int == '=' as i32;\n            *key_end = '\\0' as i32 as libc::c_char;\n            let ref mut fresh2 = (*kv.offset(element as isize)).key;\n            *fresh2 = decode_percent(key);\n            if has_value {\n                let mut value = key_end.offset(1 as libc::c_int as isize);\n                let ref mut fresh3 = (*kv.offset(element as isize)).value;\n                *fresh3 = decode_percent(value);\n            } else {\n                let ref mut fresh4 = (*kv.offset(element as isize)).value;\n                *fresh4 = key_end;\n            }\n            p_0 = kv_end.offset(1 as libc::c_int as isize);\n            element = element.wrapping_add(1);\n            element;\n        }\n    }\n    match current_block {\n        11584701595673473500 => return kv,\n        _ => {\n            free(kv as *mut libc::c_void);\n            return 0 as *mut url_key_value;\n        }\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:73 ~ oxidate_out[187d]::url_parse)",
        "span": "src/main.rs:1077:5: 1077:51 (#0)",
        "source": "(*data).query = parse_query_string(query_str);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/main.rs:25:1: 25:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/main.rs:28:1: 28:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/main.rs:27:1: 27:31 (#0)",
        "source": "use std::ffi::{CStr, CString};"
      },
      {
        "span": "src/main.rs:27:16: 27:20 (#0)",
        "source": "CStr"
      },
      {
        "span": "src/main.rs:27:22: 27:29 (#0)",
        "source": "CString"
      },
      {
        "span": "src/main.rs:22:1: 22:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/main.rs:23:1: 23:14 (#0)",
        "source": "use std::str;"
      },
      {
        "span": "src/main.rs:30:1: 30:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:48 ~ oxidate_out[187d]::scan_decimal_number)",
    "span": "src/main.rs:652:1: 661:2 (#0)",
    "pieces": [
      "src/main.rs:652:1: 661:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "unsafe extern \"C\" fn scan_decimal_number(\n    mut start: *mut libc::c_char,\n) -> *mut libc::c_char {\n    let mut p = start;\n    while *p as libc::c_int >= '0' as i32 && *p as libc::c_int <= '9' as i32 {\n        p = p.offset(1);\n        p;\n    }\n    return if p != start { p } else { 0 as *mut libc::c_char };\n}",
    "calls": [
      {
        "caller": "DefId(0:73 ~ oxidate_out[187d]::url_parse)",
        "span": "src/main.rs:960:1: 967:3 (#0)",
        "source": "let port_end_0 = match scan_decimal_number(input) {\n    Some(rest) => {\n        let digits_consumed = input.len() - rest.len();\n        // Compute the new pointer: move hostname_end by 1 plus the number of digits consumed.\n        unsafe { hostname_end.offset(1 + digits_consumed as isize) }\n    }\n    None => ptr::null_mut(),\n};"
      },
      {
        "caller": "DefId(0:73 ~ oxidate_out[187d]::url_parse)",
        "span": "src/main.rs:897:1: 903:3 (#0)",
        "source": "let port_end = match scan_decimal_number(input) {\n    Some(rest) => {\n        let digits_consumed = input.len() - rest.len();\n        unsafe { hostname_end.offset(1 + digits_consumed as isize) }\n    }\n    None => ptr::null_mut(),\n};"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/main.rs:30:1: 30:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/main.rs:22:1: 22:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/main.rs:25:1: 25:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/main.rs:28:1: 28:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/main.rs:23:1: 23:14 (#0)",
        "source": "use std::str;"
      },
      {
        "span": "src/main.rs:27:1: 27:31 (#0)",
        "source": "use std::ffi::{CStr, CString};"
      },
      {
        "span": "src/main.rs:27:16: 27:20 (#0)",
        "source": "CStr"
      },
      {
        "span": "src/main.rs:27:22: 27:29 (#0)",
        "source": "CString"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:44 ~ oxidate_out[187d]::strdup)",
    "span": "src/main.rs:568:1: 575:2 (#0)",
    "pieces": [
      "src/main.rs:568:1: 575:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "pub unsafe extern \"C\" fn strdup(mut str: *const libc::c_char) -> *mut libc::c_char {\n    let n = (strlen(str)).wrapping_add(1 as libc::c_int as libc::c_ulong) as libc::c_int;\n    let mut dup = malloc(n as libc::c_ulong) as *mut libc::c_char;\n    if !dup.is_null() {\n        strcpy(dup, str);\n    }\n    return dup;\n}",
    "calls": [
      {
        "caller": "DefId(0:73 ~ oxidate_out[187d]::url_parse)",
        "span": "src/main.rs:734:5: 734:29 (#0)",
        "source": "let mut p = strdup(url);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/main.rs:23:1: 23:14 (#0)",
        "source": "use std::str;"
      },
      {
        "span": "src/main.rs:30:1: 30:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/main.rs:27:16: 27:20 (#0)",
        "source": "CStr"
      },
      {
        "span": "src/main.rs:22:1: 22:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/main.rs:28:1: 28:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/main.rs:25:1: 25:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/main.rs:27:22: 27:29 (#0)",
        "source": "CString"
      },
      {
        "span": "src/main.rs:27:1: 27:31 (#0)",
        "source": "use std::ffi::{CStr, CString};"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:50 ~ oxidate_out[187d]::url_parse)",
    "span": "src/main.rs:716:1: 1200:2 (#0)",
    "pieces": [
      "src/main.rs:716:1: 717:4 (#0)",
      "src/main.rs:1200:1: 1200:2 (#0)"
    ],
    "sub_chunks": [
      7
    ],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn url_parse(mut url: *const libc::c_char) -> *mut url_data_t {\n   <<chunk 7>>}",
    "calls": [
      {
        "caller": "DefId(0:84 ~ oxidate_out[187d]::url_get_hostname)",
        "span": "src/main.rs:1275:20: 1275:56 (#0)",
        "source": "unsafe { url_parse(c_url.as_ptr()) }"
      },
      {
        "caller": "DefId(0:88 ~ oxidate_out[187d]::url_get_path)",
        "span": "src/main.rs:1354:20: 1354:56 (#0)",
        "source": "unsafe { url_parse(c_url.as_ptr()) }"
      },
      {
        "caller": "DefId(0:85 ~ oxidate_out[187d]::url_get_host)",
        "span": "src/main.rs:1304:20: 1304:56 (#0)",
        "source": "unsafe { url_parse(c_url.as_ptr()) }"
      },
      {
        "caller": "DefId(0:92 ~ oxidate_out[187d]::url_inspect)",
        "span": "src/main.rs:1449:9: 1449:52 (#0)",
        "source": "let parsed_ptr = url_parse(c_url.as_ptr());"
      },
      {
        "caller": "DefId(0:90 ~ oxidate_out[187d]::url_get_fragment)",
        "span": "src/main.rs:1396:20: 1396:56 (#0)",
        "source": "unsafe { url_parse(c_url.as_ptr()) }"
      },
      {
        "caller": "DefId(0:86 ~ oxidate_out[187d]::url_get_pathname)",
        "span": "src/main.rs:1328:20: 1328:56 (#0)",
        "source": "unsafe { url_parse(c_url.as_ptr()) }"
      },
      {
        "caller": "DefId(0:91 ~ oxidate_out[187d]::url_get_port)",
        "span": "src/main.rs:1428:22: 1428:58 (#0)",
        "source": "unsafe { url_parse(c_url.as_ptr()) }"
      },
      {
        "caller": "DefId(0:83 ~ oxidate_out[187d]::url_get_userinfo)",
        "span": "src/main.rs:1254:9: 1254:50 (#0)",
        "source": "let raw_data = url_parse(c_url.as_ptr());"
      }
    ],
    "globals": [
      {
        "span": "src/main.rs:118:1: 118:36 (#0)",
        "source": "pub const Unreserved: Category = 2;"
      },
      {
        "span": "src/main.rs:115:1: 115:37 (#0)",
        "source": "pub const PCharSlash: Category = 16;"
      },
      {
        "span": "src/main.rs:113:1: 113:32 (#0)",
        "source": "pub const Query: Category = 64;"
      },
      {
        "span": "src/main.rs:112:1: 112:35 (#0)",
        "source": "pub const Fragment: Category = 64;"
      },
      {
        "span": "src/main.rs:110:1: 110:36 (#0)",
        "source": "pub const IPv6Char: Category = 256;"
      },
      {
        "span": "src/main.rs:111:1: 111:36 (#0)",
        "source": "pub const Userinfo: Category = 128;"
      },
      {
        "span": "src/main.rs:116:1: 116:34 (#0)",
        "source": "pub const SubDelim: Category = 8;"
      },
      {
        "span": "src/main.rs:119:1: 119:32 (#0)",
        "source": "pub const Scheme: Category = 1;"
      }
    ],
    "imports": [
      {
        "span": "src/main.rs:23:1: 23:14 (#0)",
        "source": "use std::str;"
      },
      {
        "span": "src/main.rs:25:1: 25:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/main.rs:27:22: 27:29 (#0)",
        "source": "CString"
      },
      {
        "span": "src/main.rs:27:16: 27:20 (#0)",
        "source": "CStr"
      },
      {
        "span": "src/main.rs:28:1: 28:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/main.rs:22:1: 22:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/main.rs:27:1: 27:31 (#0)",
        "source": "use std::ffi::{CStr, CString};"
      },
      {
        "span": "src/main.rs:30:1: 30:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "src/main.rs:858:29: 990:30 (#0)",
        "pieces": [
          "src/main.rs:858:29: 990:30 (#0)"
        ],
        "num_lines": 103,
        "source": "hostname_end = 0 as *mut libc::c_char;\n                            if *p as libc::c_int == '[' as i32 {\n                                p = p.offset(1);\n                                p;\n                                hostname_end = scan_part(\n                                    p,\n                                    IPv6Char,\n                                    ']' as i32 as libc::c_char,\n                                    '\\0' as i32 as libc::c_char,\n                                );\n                                if hostname_end.is_null() {\n                                    fprintf(\n                                        stderr,\n                                        b\"ERROR %s Line %u! p=\\xC2\\xAB%s\\xC2\\xBB\\n\\0\" as *const u8\n                                            as *const libc::c_char,\n                                        b\"/workspace/programs/url/url.c\\0\" as *const u8\n                                            as *const libc::c_char,\n                                        234 as libc::c_int,\n                                        p,\n                                    );\n                                    current_block = 17635118975278168935;\n                                } else {\n                                    *hostname_end = '\\0' as i32 as libc::c_char;\n                                    (*data).host = p;\n                                    hostname_end = hostname_end.offset(1);\n                                    hostname_end;\n                                    if hostname_end < p_end as *mut libc::c_char && !is_ssh\n                                        && *hostname_end as libc::c_int == ':' as i32\n                                    {\n                                        let mut port_end = scan_decimal_number(\n                                            hostname_end.offset(1 as libc::c_int as isize),\n                                        );\n                                        if !port_end.is_null() {\n                                            (*data)\n                                                .port = hostname_end.offset(1 as libc::c_int as isize);\n                                            p = port_end;\n                                            current_block = 7252614138838059896;\n                                        } else {\n                                            fprintf(\n                                                stderr,\n                                                b\"ERROR %s Line %u! p=\\xC2\\xAB%s\\xC2\\xBB\\n\\0\" as *const u8\n                                                    as *const libc::c_char,\n                                                b\"/workspace/programs/url/url.c\\0\" as *const u8\n                                                    as *const libc::c_char,\n                                                247 as libc::c_int,\n                                                p,\n                                            );\n                                            current_block = 17635118975278168935;\n                                        }\n                                    } else {\n                                        p = hostname_end;\n                                        current_block = 7252614138838059896;\n                                    }\n                                }\n                            } else {\n                                hostname_end = scan_part(\n                                    p,\n                                    (Unreserved as libc::c_int | SubDelim as libc::c_int)\n                                        as Category,\n                                    ':' as i32 as libc::c_char,\n                                    '/' as i32 as libc::c_char,\n                                );\n                                if hostname_end.is_null() {\n                                    fprintf(\n                                        stderr,\n                                        b\"ERROR %s Line %u! p=\\xC2\\xAB%s\\xC2\\xBB\\n\\0\" as *const u8\n                                            as *const libc::c_char,\n                                        b\"/workspace/programs/url/url.c\\0\" as *const u8\n                                            as *const libc::c_char,\n                                        255 as libc::c_int,\n                                        p,\n                                    );\n                                    current_block = 17635118975278168935;\n                                } else {\n                                    (*data).host = p;\n                                    if !is_ssh && *hostname_end as libc::c_int == ':' as i32 {\n                                        *hostname_end = '\\0' as i32 as libc::c_char;\n                                        let mut port_end_0 = scan_decimal_number(\n                                            hostname_end.offset(1 as libc::c_int as isize),\n                                        );\n                                        if !port_end_0.is_null() {\n                                            (*data)\n                                                .port = hostname_end.offset(1 as libc::c_int as isize);\n                                            p = port_end_0;\n                                            current_block = 7252614138838059896;\n                                        } else {\n                                            fprintf(\n                                                stderr,\n                                                b\"ERROR %s Line %u! p=\\xC2\\xAB%s\\xC2\\xBB\\n\\0\" as *const u8\n                                                    as *const libc::c_char,\n                                                b\"/workspace/programs/url/url.c\\0\" as *const u8\n                                                    as *const libc::c_char,\n                                                267 as libc::c_int,\n                                                p,\n                                            );\n                                            current_block = 17635118975278168935;\n                                        }\n                                    } else {\n                                        p = hostname_end;\n                                        current_block = 7252614138838059896;\n                                    }\n                                }\n                            }",
        "sub_chunks": [],
        "live_in": [
          "mut url: *const i8",
          "mut p_end: *const i8",
          "mut is_ssh: bool",
          "mut hostname_end: *mut i8",
          "mut current_block: u64",
          "mut data: *mut url_data",
          "mut p: *mut i8",
          "is_ssh: bool"
        ],
        "live_out": [
          "mut url: *const i8",
          "mut p_end: *const i8",
          "mut is_ssh: bool",
          "mut hostname_end: *mut i8",
          "mut current_block: u64",
          "mut data: *mut url_data",
          "mut p: *mut i8",
          "is_ssh: bool"
        ]
      },
      {
        "chunk_id": 1,
        "span": "src/main.rs:991:29: 1178:30 (#0)",
        "pieces": [
          "src/main.rs:991:29: 1178:30 (#0)"
        ],
        "num_lines": 135,
        "source": "match current_block {\n                                17635118975278168935 => {}\n                                _ => {\n                                    memmove(\n                                        second_slash as *mut libc::c_void,\n                                        second_slash.offset(1 as libc::c_int as isize)\n                                            as *const libc::c_void,\n                                        p.offset_from(second_slash) as libc::c_long as libc::c_ulong,\n                                    );\n                                    if !((*data).userinfo).is_null() {\n                                        (*data).userinfo = ((*data).userinfo).offset(-1);\n                                        (*data).userinfo;\n                                    }\n                                    (*data).host = ((*data).host).offset(-1);\n                                    (*data).host;\n                                    if !((*data).port).is_null() {\n                                        (*data).port = ((*data).port).offset(-1);\n                                        (*data).port;\n                                    }\n                                    *p\n                                        .offset(\n                                            -(1 as libc::c_int) as isize,\n                                        ) = '\\0' as i32 as libc::c_char;\n                                    if is_ssh as libc::c_int != 0\n                                        && *p as libc::c_int == ':' as i32\n                                    {\n                                        p = p.offset(1);\n                                        p;\n                                    }\n                                    path_end = scan_part(\n                                        p,\n                                        PCharSlash,\n                                        '?' as i32 as libc::c_char,\n                                        '#' as i32 as libc::c_char,\n                                    );\n                                    if path_end.is_null() {\n                                        fprintf(\n                                            stderr,\n                                            b\"ERROR %s Line %u! p=\\xC2\\xAB%s\\xC2\\xBB\\n\\0\" as *const u8\n                                                as *const libc::c_char,\n                                            b\"/workspace/programs/url/url.c\\0\" as *const u8\n                                                as *const libc::c_char,\n                                            295 as libc::c_int,\n                                            p,\n                                        );\n                                    } else {\n                                        has_query = *path_end as libc::c_int == '?' as i32;\n                                        has_fragment = *path_end as libc::c_int == '#' as i32;\n                                        *path_end = '\\0' as i32 as libc::c_char;\n                                        (*data).path = decode_percent(p);\n                                        p = path_end.offset(1 as libc::c_int as isize);\n                                        if has_query {\n                                            let mut query_end = scan_part(\n                                                p,\n                                                Query,\n                                                '#' as i32 as libc::c_char,\n                                                '\\0' as i32 as libc::c_char,\n                                            );\n                                            if !query_end.is_null() {\n                                                let has_fragment_0 = *query_end as libc::c_int\n                                                    == '#' as i32;\n                                                *query_end = '\\0' as i32 as libc::c_char;\n                                                (*data).query = parse_query_string(p, query_end);\n                                                if has_fragment_0 {\n                                                    let mut fragment_end = scan_part(\n                                                        query_end.offset(1 as libc::c_int as isize),\n                                                        Fragment,\n                                                        '\\0' as i32 as libc::c_char,\n                                                        '\\0' as i32 as libc::c_char,\n                                                    );\n                                                    if !fragment_end.is_null() {\n                                                        (*data)\n                                                            .fragment = decode_percent(\n                                                            query_end.offset(1 as libc::c_int as isize),\n                                                        );\n                                                        current_block = 6406431739208918833;\n                                                    } else {\n                                                        fprintf(\n                                                            stderr,\n                                                            b\"ERROR %s Line %u! p=\\xC2\\xAB%s\\xC2\\xBB\\n\\0\" as *const u8\n                                                                as *const libc::c_char,\n                                                            b\"/workspace/programs/url/url.c\\0\" as *const u8\n                                                                as *const libc::c_char,\n                                                            319 as libc::c_int,\n                                                            p,\n                                                        );\n                                                        current_block = 17635118975278168935;\n                                                    }\n                                                } else {\n                                                    current_block = 6406431739208918833;\n                                                }\n                                            } else {\n                                                fprintf(\n                                                    stderr,\n                                                    b\"ERROR %s Line %u! p=\\xC2\\xAB%s\\xC2\\xBB\\n\\0\" as *const u8\n                                                        as *const libc::c_char,\n                                                    b\"/workspace/programs/url/url.c\\0\" as *const u8\n                                                        as *const libc::c_char,\n                                                    323 as libc::c_int,\n                                                    p,\n                                                );\n                                                current_block = 17635118975278168935;\n                                            }\n                                        } else if has_fragment {\n                                            let mut fragment_end_0 = scan_part(\n                                                p,\n                                                Fragment,\n                                                '\\0' as i32 as libc::c_char,\n                                                '\\0' as i32 as libc::c_char,\n                                            );\n                                            if !fragment_end_0.is_null() {\n                                                (*data).fragment = decode_percent(p);\n                                                current_block = 6406431739208918833;\n                                            } else {\n                                                fprintf(\n                                                    stderr,\n                                                    b\"ERROR %s Line %u! p=\\xC2\\xAB%s\\xC2\\xBB\\n\\0\" as *const u8\n                                                        as *const libc::c_char,\n                                                    b\"/workspace/programs/url/url.c\\0\" as *const u8\n                                                        as *const libc::c_char,\n                                                    332 as libc::c_int,\n                                                    p,\n                                                );\n                                                current_block = 17635118975278168935;\n                                            }\n                                        } else {\n                                            current_block = 6406431739208918833;\n                                        }\n                                        match current_block {\n                                            17635118975278168935 => {}\n                                            _ => return data,\n                                        }\n                                    }\n                                }\n                            }",
        "sub_chunks": [],
        "live_in": [
          "mut url: *const i8",
          "mut is_ssh: bool",
          "mut second_slash: *mut i8",
          "mut path_end: *mut i8",
          "mut has_query: bool",
          "mut has_fragment: bool",
          "mut current_block: u64",
          "mut data: *mut url_data",
          "mut p: *mut i8",
          "p_str: &str",
          "is_ssh: bool"
        ],
        "live_out": [
          "mut url: *const i8",
          "mut is_ssh: bool",
          "mut second_slash: *mut i8",
          "mut path_end: *mut i8",
          "mut has_query: bool",
          "mut has_fragment: bool",
          "mut current_block: u64",
          "mut data: *mut url_data",
          "mut p: *mut i8",
          "p_str: &str",
          "is_ssh: bool"
        ]
      },
      {
        "chunk_id": 2,
        "span": "src/main.rs:834:25: 1179:26 (#0)",
        "pieces": [
          "src/main.rs:834:25: 858:28 (#0)",
          "src/main.rs:991:1: 991:28 (#0)",
          "src/main.rs:1179:1: 1179:26 (#0)"
        ],
        "num_lines": 27,
        "source": "userinfo_end = scan_part(\n                            p,\n                            Userinfo,\n                            '@' as i32 as libc::c_char,\n                            '\\0' as i32 as libc::c_char,\n                        );\n                        if !userinfo_end.is_null()\n                            && *userinfo_end as libc::c_int == '@' as i32\n                        {\n                            *userinfo_end = '\\0' as i32 as libc::c_char;\n                            (*data).userinfo = p;\n                            p = userinfo_end.offset(1 as libc::c_int as isize);\n                        }\n                        if p >= p_end as *mut libc::c_char {\n                            fprintf(\n                                stderr,\n                                b\"ERROR %s Line %u! p=\\xC2\\xAB%s\\xC2\\xBB\\n\\0\" as *const u8\n                                    as *const libc::c_char,\n                                b\"/workspace/programs/url/url.c\\0\" as *const u8\n                                    as *const libc::c_char,\n                                225 as libc::c_int,\n                                p,\n                            );\n                        } else {\n                           <<chunk 0>>                           <<chunk 1>>                        }",
        "sub_chunks": [
          0,
          1
        ],
        "live_in": [
          "mut url: *const i8",
          "mut p_end: *const i8",
          "mut is_ssh: bool",
          "mut second_slash: *mut i8",
          "mut userinfo_end: *mut i8",
          "mut hostname_end: *mut i8",
          "mut path_end: *mut i8",
          "mut has_query: bool",
          "mut has_fragment: bool",
          "mut current_block: u64",
          "mut data: *mut url_data",
          "mut p: *mut i8",
          "p_str: &str",
          "is_ssh: bool"
        ],
        "live_out": [
          "mut url: *const i8",
          "mut p_end: *const i8",
          "mut is_ssh: bool",
          "mut second_slash: *mut i8",
          "mut userinfo_end: *mut i8",
          "mut hostname_end: *mut i8",
          "mut path_end: *mut i8",
          "mut has_query: bool",
          "mut has_fragment: bool",
          "mut current_block: u64",
          "mut data: *mut url_data",
          "mut p: *mut i8",
          "p_str: &str",
          "is_ssh: bool"
        ]
      },
      {
        "chunk_id": 3,
        "span": "src/main.rs:820:5: 1180:22 (#0)",
        "pieces": [
          "src/main.rs:820:5: 834:24 (#0)",
          "src/main.rs:1180:1: 1180:22 (#0)"
        ],
        "num_lines": 16,
        "source": "second_slash = p;\n                    p = p.offset(1);\n                    p;\n                    if p >= p_end as *mut libc::c_char {\n                        fprintf(\n                            stderr,\n                            b\"ERROR %s Line %u! p=\\xC2\\xAB%s\\xC2\\xBB\\n\\0\" as *const u8\n                                as *const libc::c_char,\n                            b\"/workspace/programs/url/url.c\\0\" as *const u8\n                                as *const libc::c_char,\n                            215 as libc::c_int,\n                            p,\n                        );\n                    } else {\n                       <<chunk 2>>                    }",
        "sub_chunks": [
          2
        ],
        "live_in": [
          "mut url: *const i8",
          "mut p_end: *const i8",
          "mut is_ssh: bool",
          "mut second_slash: *mut i8",
          "mut userinfo_end: *mut i8",
          "mut hostname_end: *mut i8",
          "mut path_end: *mut i8",
          "mut has_query: bool",
          "mut has_fragment: bool",
          "mut current_block: u64",
          "mut data: *mut url_data",
          "mut p: *mut i8",
          "p_str: &str",
          "is_ssh: bool"
        ],
        "live_out": [
          "mut url: *const i8",
          "mut p_end: *const i8",
          "mut is_ssh: bool",
          "mut second_slash: *mut i8",
          "mut userinfo_end: *mut i8",
          "mut hostname_end: *mut i8",
          "mut path_end: *mut i8",
          "mut has_query: bool",
          "mut has_fragment: bool",
          "mut current_block: u64",
          "mut data: *mut url_data",
          "mut p: *mut i8",
          "p_str: &str",
          "is_ssh: bool"
        ]
      },
      {
        "chunk_id": 4,
        "span": "src/main.rs:788:17: 1185:292 (#0)",
        "pieces": [
          "src/main.rs:788:17: 820:4 (#0)",
          "src/main.rs:1181:1: 1185:292 (#0)"
        ],
        "num_lines": 15,
        "source": "p = p.offset(1);\n                p;\n                if p >= p_end as *mut libc::c_char || *p as libc::c_int != '/' as i32 {\n                    fprintf(\n                        stderr,\n                        b\"ERROR %s Line %u! p=\\xC2\\xAB%s\\xC2\\xBB\\n\\0\" as *const u8\n                            as *const libc::c_char,\n                        b\"/workspace/programs/url/url.c\\0\" as *const u8\n                            as *const libc::c_char,\n                        209 as libc::c_int,\n                        p,\n                    );\n                } else {\n                   <<chunk 3>>                }",
        "sub_chunks": [
          3
        ],
        "live_in": [
          "mut url: *const i8",
          "mut p_end: *const i8",
          "mut is_ssh: bool",
          "mut second_slash: *mut i8",
          "mut userinfo_end: *mut i8",
          "mut hostname_end: *mut i8",
          "mut path_end: *mut i8",
          "mut has_query: bool",
          "mut has_fragment: bool",
          "mut current_block: u64",
          "mut data: *mut url_data",
          "mut p: *mut i8",
          "p_str: &str",
          "is_ssh: bool"
        ],
        "live_out": [
          "mut url: *const i8",
          "mut p_end: *const i8",
          "mut is_ssh: bool",
          "mut second_slash: *mut i8",
          "mut userinfo_end: *mut i8",
          "mut hostname_end: *mut i8",
          "mut path_end: *mut i8",
          "mut has_query: bool",
          "mut has_fragment: bool",
          "mut current_block: u64",
          "mut data: *mut url_data",
          "mut p: *mut i8",
          "p_str: &str",
          "is_ssh: bool"
        ]
      },
      {
        "chunk_id": 5,
        "span": "src/main.rs:768:13: 1187:14 (#0)",
        "pieces": [
          "src/main.rs:768:13: 788:16 (#0)",
          "src/main.rs:1187:1: 1187:14 (#0)"
        ],
        "num_lines": 17,
        "source": "*protocol_end = '\\0' as i32 as libc::c_char;\n            (*data).protocol = p;\n            is_ssh = url_is_ssh((*data).protocol);\n            p = protocol_end.offset(1 as libc::c_int as isize);\n            if p >= p_end as *mut libc::c_char || *p as libc::c_int != '/' as i32 {\n                fprintf(\n                    stderr,\n                    b\"ERROR %s Line %u! p=\\xC2\\xAB%s\\xC2\\xBB\\n\\0\" as *const u8\n                        as *const libc::c_char,\n                    b\"/workspace/programs/url/url.c\\0\" as *const u8\n                        as *const libc::c_char,\n                    205 as libc::c_int,\n                    p,\n                );\n            } else {\n               <<chunk 4>>            }",
        "sub_chunks": [
          4
        ],
        "live_in": [
          "mut url: *const i8",
          "mut p_end: *const i8",
          "mut protocol_end: *mut i8",
          "mut is_ssh: bool",
          "mut second_slash: *mut i8",
          "mut userinfo_end: *mut i8",
          "mut hostname_end: *mut i8",
          "mut path_end: *mut i8",
          "mut has_query: bool",
          "mut has_fragment: bool",
          "mut current_block: u64",
          "mut data: *mut url_data",
          "mut p: *mut i8",
          "p_str: &str"
        ],
        "live_out": [
          "mut url: *const i8",
          "mut p_end: *const i8",
          "mut protocol_end: *mut i8",
          "mut is_ssh: bool",
          "mut second_slash: *mut i8",
          "mut userinfo_end: *mut i8",
          "mut hostname_end: *mut i8",
          "mut path_end: *mut i8",
          "mut has_query: bool",
          "mut has_fragment: bool",
          "mut current_block: u64",
          "mut data: *mut url_data",
          "mut p: *mut i8",
          "p_str: &str",
          "protocol: &str",
          "is_ssh: bool"
        ]
      },
      {
        "chunk_id": 6,
        "span": "src/main.rs:745:9: 1191:2 (#0)",
        "pieces": [
          "src/main.rs:745:9: 768:12 (#0)",
          "src/main.rs:1188:1: 1191:2 (#0)"
        ],
        "num_lines": 20,
        "source": "(*data).whole_url = p;\n        p_end = p.offset(strlen(p) as isize);\n        protocol_end = scan_part(\n            p,\n            Scheme,\n            ':' as i32 as libc::c_char,\n            '\\0' as i32 as libc::c_char,\n        );\n        if protocol_end.is_null() || *protocol_end as libc::c_int == '\\0' as i32 {\n            fprintf(\n                stderr,\n                b\"ERROR %s Line %u! p=\\xC2\\xAB%s\\xC2\\xBB\\n\\0\" as *const u8\n                    as *const libc::c_char,\n                b\"/workspace/programs/url/url.c\\0\" as *const u8 as *const libc::c_char,\n                197 as libc::c_int,\n                p,\n            );\n        } else {\n           <<chunk 5>>        }",
        "sub_chunks": [
          5
        ],
        "live_in": [
          "mut url: *const i8",
          "mut p_end: *const i8",
          "mut protocol_end: *mut i8",
          "mut is_ssh: bool",
          "mut second_slash: *mut i8",
          "mut userinfo_end: *mut i8",
          "mut hostname_end: *mut i8",
          "mut path_end: *mut i8",
          "mut has_query: bool",
          "mut has_fragment: bool",
          "mut current_block: u64",
          "mut data: *mut url_data",
          "mut p: *mut i8"
        ],
        "live_out": [
          "mut url: *const i8",
          "mut p_end: *const i8",
          "mut protocol_end: *mut i8",
          "mut is_ssh: bool",
          "mut second_slash: *mut i8",
          "mut userinfo_end: *mut i8",
          "mut hostname_end: *mut i8",
          "mut path_end: *mut i8",
          "mut has_query: bool",
          "mut has_fragment: bool",
          "mut current_block: u64",
          "mut data: *mut url_data",
          "mut p: *mut i8"
        ]
      },
      {
        "chunk_id": 7,
        "span": "src/main.rs:717:5: 1199:33 (#0)",
        "pieces": [
          "src/main.rs:717:5: 745:8 (#0)",
          "src/main.rs:1193:1: 1199:33 (#0)"
        ],
        "num_lines": 32,
        "source": "let mut p_end: *const libc::c_char = 0 as *const libc::c_char;\n    let mut protocol_end: *mut libc::c_char = 0 as *mut libc::c_char;\n    let mut is_ssh: bool = false;\n    let mut second_slash: *mut libc::c_char = 0 as *mut libc::c_char;\n    let mut userinfo_end: *mut libc::c_char = 0 as *mut libc::c_char;\n    let mut hostname_end: *mut libc::c_char = 0 as *mut libc::c_char;\n    let mut path_end: *mut libc::c_char = 0 as *mut libc::c_char;\n    let mut has_query: bool = false;\n    let mut has_fragment: bool = false;\n    let mut current_block: u64;\n    let mut data = calloc(\n        1 as libc::c_int as libc::c_ulong,\n        ::core::mem::size_of::<url_data_t>() as libc::c_ulong,\n    ) as *mut url_data_t;\n    if data.is_null() {\n        return 0 as *mut url_data_t;\n    }\n    let mut p = strdup(url);\n    if p.is_null() {\n        fprintf(\n            stderr,\n            b\"ERROR %s Line %u! p=\\xC2\\xAB%s\\xC2\\xBB\\n\\0\" as *const u8\n                as *const libc::c_char,\n            b\"/workspace/programs/url/url.c\\0\" as *const u8 as *const libc::c_char,\n            190 as libc::c_int,\n            p,\n        );\n    } else {\n       <<chunk 6>>    }\n    url_free(data);\n    return 0 as *mut url_data_t;",
        "sub_chunks": [
          6
        ],
        "live_in": [
          "mut url: *const i8"
        ],
        "live_out": [
          "mut url: *const i8",
          "mut p_end: *const i8",
          "mut protocol_end: *mut i8",
          "mut is_ssh: bool",
          "mut second_slash: *mut i8",
          "mut userinfo_end: *mut i8",
          "mut hostname_end: *mut i8",
          "mut path_end: *mut i8",
          "mut has_query: bool",
          "mut has_fragment: bool",
          "mut current_block: u64",
          "mut data: *mut url_data",
          "mut p: *mut i8"
        ]
      }
    ]
  },
  {
    "func_defid": "DefId(0:64 ~ oxidate_out[187d]::url_data_inspect)",
    "span": "src/main.rs:1455:1: 1520:2 (#0)",
    "pieces": [
      "src/main.rs:1455:1: 1520:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 79,
    "source": "pub unsafe extern \"C\" fn url_data_inspect(mut data: *const url_data_t) {\n    printf(b\"#url =>\\n\\0\" as *const u8 as *const libc::c_char);\n    if !((*data).protocol).is_null() {\n        printf(\n            b\"    .protocol: \\\"%s\\\"\\n\\0\" as *const u8 as *const libc::c_char,\n            (*data).protocol,\n        );\n    } else {\n        printf(b\"    .protocol: (NULL)\\n\\0\" as *const u8 as *const libc::c_char);\n    }\n    if !((*data).host).is_null() {\n        printf(\n            b\"    .host: \\\"%s\\\"\\n\\0\" as *const u8 as *const libc::c_char,\n            (*data).host,\n        );\n    } else {\n        printf(b\"    .host: (NULL)\\n\\0\" as *const u8 as *const libc::c_char);\n    }\n    if !((*data).userinfo).is_null() {\n        printf(\n            b\"    .userinfo: \\\"%s\\\"\\n\\0\" as *const u8 as *const libc::c_char,\n            (*data).userinfo,\n        );\n    } else {\n        printf(b\"    .userinfo: (NULL)\\n\\0\" as *const u8 as *const libc::c_char);\n    }\n    if !((*data).host).is_null() {\n        printf(\n            b\"    .host: \\\"%s\\\"\\n\\0\" as *const u8 as *const libc::c_char,\n            (*data).host,\n        );\n    } else {\n        printf(b\"    .host: (NULL)\\n\\0\" as *const u8 as *const libc::c_char);\n    }\n    if !((*data).port).is_null() {\n        printf(\n            b\"    .port: \\\"%s\\\"\\n\\0\" as *const u8 as *const libc::c_char,\n            (*data).port,\n        );\n    } else {\n        printf(b\"    .port: (NULL)\\n\\0\" as *const u8 as *const libc::c_char);\n    }\n    if !((*data).path).is_null() {\n        printf(\n            b\"    .path: \\\"%s\\\"\\n\\0\" as *const u8 as *const libc::c_char,\n            (*data).path,\n        );\n    } else {\n        printf(b\"    .path: (NULL)\\n\\0\" as *const u8 as *const libc::c_char);\n    }\n    if !((*data).query).is_null() {\n        let mut nr = 0 as libc::c_int as libc::c_uint;\n        while !((*((*data).query).offset(nr as isize)).key).is_null() {\n            printf(\n                b\"    .query[%u]: \\\"%s\\\" -> \\0\" as *const u8 as *const libc::c_char,\n                nr,\n                (*((*data).query).offset(nr as isize)).key,\n            );\n            if !((*((*data).query).offset(nr as isize)).value).is_null() {\n                printf(\n                    b\"\\\"%s\\\"\\n\\0\" as *const u8 as *const libc::c_char,\n                    (*((*data).query).offset(nr as isize)).value,\n                );\n            } else {\n                printf(b\"(NULL)\\n\\0\" as *const u8 as *const libc::c_char);\n            }\n            nr = nr.wrapping_add(1);\n            nr;\n        }\n    }\n    if !((*data).fragment).is_null() {\n        printf(\n            b\"    .fragment: \\\"%s\\\"\\n\\0\" as *const u8 as *const libc::c_char,\n            (*data).fragment,\n        );\n    } else {\n        printf(b\"    .fragment: (NULL)\\n\\0\" as *const u8 as *const libc::c_char);\n    };\n}",
    "calls": [
      {
        "caller": "DefId(0:92 ~ oxidate_out[187d]::url_inspect)",
        "span": "src/main.rs:1450:9: 1450:40 (#0)",
        "source": "url_data_inspect(&*parsed_ptr);"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/main.rs:27:22: 27:29 (#0)",
        "source": "CString"
      },
      {
        "span": "src/main.rs:22:1: 22:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/main.rs:27:1: 27:31 (#0)",
        "source": "use std::ffi::{CStr, CString};"
      },
      {
        "span": "src/main.rs:28:1: 28:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/main.rs:25:1: 25:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/main.rs:27:16: 27:20 (#0)",
        "source": "CStr"
      },
      {
        "span": "src/main.rs:23:1: 23:14 (#0)",
        "source": "use std::str;"
      },
      {
        "span": "src/main.rs:30:1: 30:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:63 ~ oxidate_out[187d]::url_inspect)",
    "span": "src/main.rs:1446:1: 1452:2 (#0)",
    "pieces": [
      "src/main.rs:1446:1: 1452:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "pub unsafe extern \"C\" fn url_inspect(mut url: *const libc::c_char) {\n    url_data_inspect(url_parse(url));\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/main.rs:25:1: 25:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/main.rs:22:1: 22:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/main.rs:27:1: 27:31 (#0)",
        "source": "use std::ffi::{CStr, CString};"
      },
      {
        "span": "src/main.rs:27:22: 27:29 (#0)",
        "source": "CString"
      },
      {
        "span": "src/main.rs:28:1: 28:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/main.rs:30:1: 30:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/main.rs:27:16: 27:20 (#0)",
        "source": "CStr"
      },
      {
        "span": "src/main.rs:23:1: 23:14 (#0)",
        "source": "use std::str;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:59 ~ oxidate_out[187d]::url_get_path)",
    "span": "src/main.rs:1350:1: 1371:2 (#0)",
    "pieces": [
      "src/main.rs:1350:1: 1371:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "pub unsafe extern \"C\" fn url_get_path(\n    mut url: *const libc::c_char,\n) -> *mut libc::c_char {\n    let mut data = url_parse(url);\n    let mut out = if !data.is_null() && !((*data).path).is_null() {\n        strdup((*data).path)\n    } else {\n        0 as *mut libc::c_char\n    };\n    url_free(data);\n    return out;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/main.rs:22:1: 22:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/main.rs:27:1: 27:31 (#0)",
        "source": "use std::ffi::{CStr, CString};"
      },
      {
        "span": "src/main.rs:28:1: 28:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/main.rs:25:1: 25:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/main.rs:27:16: 27:20 (#0)",
        "source": "CStr"
      },
      {
        "span": "src/main.rs:30:1: 30:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/main.rs:27:22: 27:29 (#0)",
        "source": "CString"
      },
      {
        "span": "src/main.rs:23:1: 23:14 (#0)",
        "source": "use std::str;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:55 ~ oxidate_out[187d]::url_get_userinfo)",
    "span": "src/main.rs:1250:1: 1270:2 (#0)",
    "pieces": [
      "src/main.rs:1250:1: 1270:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "pub unsafe extern \"C\" fn url_get_userinfo(\n    mut url: *const libc::c_char,\n) -> *mut libc::c_char {\n    let mut data = url_parse(url);\n    let mut out = if !data.is_null() && !((*data).userinfo).is_null() {\n        strdup((*data).userinfo)\n    } else {\n        0 as *mut libc::c_char\n    };\n    url_free(data);\n    return out;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/main.rs:27:22: 27:29 (#0)",
        "source": "CString"
      },
      {
        "span": "src/main.rs:25:1: 25:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/main.rs:23:1: 23:14 (#0)",
        "source": "use std::str;"
      },
      {
        "span": "src/main.rs:27:1: 27:31 (#0)",
        "source": "use std::ffi::{CStr, CString};"
      },
      {
        "span": "src/main.rs:30:1: 30:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/main.rs:22:1: 22:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/main.rs:28:1: 28:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/main.rs:27:16: 27:20 (#0)",
        "source": "CStr"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:61 ~ oxidate_out[187d]::url_get_fragment)",
    "span": "src/main.rs:1392:1: 1421:2 (#0)",
    "pieces": [
      "src/main.rs:1392:1: 1421:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "pub unsafe extern \"C\" fn url_get_fragment(\n    mut url: *const libc::c_char,\n) -> *mut libc::c_char {\n    let mut data = url_parse(url);\n    let mut out = if !data.is_null() && !((*data).fragment).is_null() {\n        strdup((*data).fragment)\n    } else {\n        0 as *mut libc::c_char\n    };\n    url_free(data);\n    return out;\n}",
    "calls": [
      {
        "caller": "DefId(0:58 ~ oxidate_out[187d]::url_get_hash)",
        "span": "src/main.rs:126:42: 128:2 (#0)",
        "source": "{\n    url_get_fragment(url).unwrap_or_default()\n}"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/main.rs:27:1: 27:31 (#0)",
        "source": "use std::ffi::{CStr, CString};"
      },
      {
        "span": "src/main.rs:23:1: 23:14 (#0)",
        "source": "use std::str;"
      },
      {
        "span": "src/main.rs:25:1: 25:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/main.rs:27:22: 27:29 (#0)",
        "source": "CString"
      },
      {
        "span": "src/main.rs:30:1: 30:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/main.rs:28:1: 28:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/main.rs:22:1: 22:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/main.rs:27:16: 27:20 (#0)",
        "source": "CStr"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:66 ~ oxidate_out[187d]::main)",
    "span": "src/main.rs:1530:1: 1532:2 (#0)",
    "pieces": [
      "src/main.rs:1530:1: 1532:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 1,
    "source": "pub fn main() {}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/main.rs:22:1: 22:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/main.rs:27:22: 27:29 (#0)",
        "source": "CString"
      },
      {
        "span": "src/main.rs:27:1: 27:31 (#0)",
        "source": "use std::ffi::{CStr, CString};"
      },
      {
        "span": "src/main.rs:25:1: 25:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/main.rs:23:1: 23:14 (#0)",
        "source": "use std::str;"
      },
      {
        "span": "src/main.rs:27:16: 27:20 (#0)",
        "source": "CStr"
      },
      {
        "span": "src/main.rs:28:1: 28:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/main.rs:30:1: 30:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:60 ~ oxidate_out[187d]::url_get_query_value)",
    "span": "src/main.rs:1374:1: 1390:2 (#0)",
    "pieces": [
      "src/main.rs:1374:1: 1390:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 17,
    "source": "pub unsafe extern \"C\" fn url_get_query_value(\n    mut url: *const url_data_t,\n    mut key: *const libc::c_char,\n) -> *const libc::c_char {\n    if ((*url).query).is_null() {\n        return 0 as *const libc::c_char;\n    }\n    let mut kv = (*url).query;\n    while !((*kv).key).is_null() {\n        if strcmp((*kv).key, key) == 0 as libc::c_int {\n            return (*kv).value;\n        }\n        kv = kv.offset(1);\n        kv;\n    }\n    return 0 as *const libc::c_char;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/main.rs:28:1: 28:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/main.rs:22:1: 22:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/main.rs:27:22: 27:29 (#0)",
        "source": "CString"
      },
      {
        "span": "src/main.rs:30:1: 30:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/main.rs:25:1: 25:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/main.rs:27:16: 27:20 (#0)",
        "source": "CStr"
      },
      {
        "span": "src/main.rs:27:1: 27:31 (#0)",
        "source": "use std::ffi::{CStr, CString};"
      },
      {
        "span": "src/main.rs:23:1: 23:14 (#0)",
        "source": "use std::str;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:56 ~ oxidate_out[187d]::url_get_hostname)",
    "span": "src/main.rs:1273:1: 1296:2 (#0)",
    "pieces": [
      "src/main.rs:1273:1: 1296:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "pub unsafe extern \"C\" fn url_get_hostname(\n    mut url: *const libc::c_char,\n) -> *mut libc::c_char {\n    let mut data = url_parse(url);\n    let mut out = if !data.is_null() && !((*data).host).is_null() {\n        strdup((*data).host)\n    } else {\n        0 as *mut libc::c_char\n    };\n    url_free(data);\n    return out;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/main.rs:27:16: 27:20 (#0)",
        "source": "CStr"
      },
      {
        "span": "src/main.rs:27:22: 27:29 (#0)",
        "source": "CString"
      },
      {
        "span": "src/main.rs:22:1: 22:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/main.rs:25:1: 25:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/main.rs:27:1: 27:31 (#0)",
        "source": "use std::ffi::{CStr, CString};"
      },
      {
        "span": "src/main.rs:28:1: 28:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/main.rs:30:1: 30:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/main.rs:23:1: 23:14 (#0)",
        "source": "use std::str;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:39 ~ oxidate_out[187d]::url_get_hash)",
    "span": "src/main.rs:126:1: 128:2 (#0)",
    "pieces": [
      "src/main.rs:126:1: 128:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 3,
    "source": "unsafe extern \"C\" fn url_get_hash(mut url: *const libc::c_char) -> *mut libc::c_char {\n    return url_get_fragment(url);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/main.rs:27:1: 27:31 (#0)",
        "source": "use std::ffi::{CStr, CString};"
      },
      {
        "span": "src/main.rs:25:1: 25:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/main.rs:30:1: 30:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/main.rs:23:1: 23:14 (#0)",
        "source": "use std::str;"
      },
      {
        "span": "src/main.rs:27:16: 27:20 (#0)",
        "source": "CStr"
      },
      {
        "span": "src/main.rs:28:1: 28:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/main.rs:22:1: 22:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/main.rs:27:22: 27:29 (#0)",
        "source": "CString"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:58 ~ oxidate_out[187d]::url_get_pathname)",
    "span": "src/main.rs:1326:1: 1347:2 (#0)",
    "pieces": [
      "src/main.rs:1326:1: 1347:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "pub unsafe extern \"C\" fn url_get_pathname(\n    mut url: *const libc::c_char,\n) -> *mut libc::c_char {\n    let mut data = url_parse(url);\n    let mut out = if !data.is_null() && !((*data).path).is_null() {\n        strdup((*data).path)\n    } else {\n        0 as *mut libc::c_char\n    };\n    url_free(data);\n    return out;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/main.rs:28:1: 28:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/main.rs:25:1: 25:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/main.rs:23:1: 23:14 (#0)",
        "source": "use std::str;"
      },
      {
        "span": "src/main.rs:30:1: 30:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/main.rs:27:22: 27:29 (#0)",
        "source": "CString"
      },
      {
        "span": "src/main.rs:22:1: 22:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/main.rs:27:16: 27:20 (#0)",
        "source": "CStr"
      },
      {
        "span": "src/main.rs:27:1: 27:31 (#0)",
        "source": "use std::ffi::{CStr, CString};"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:62 ~ oxidate_out[187d]::url_get_port)",
    "span": "src/main.rs:1424:1: 1443:2 (#0)",
    "pieces": [
      "src/main.rs:1424:1: 1443:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "pub unsafe extern \"C\" fn url_get_port(\n    mut url: *const libc::c_char,\n) -> *mut libc::c_char {\n    let mut data = url_parse(url);\n    let mut out = if !data.is_null() && !((*data).port).is_null() {\n        strdup((*data).port)\n    } else {\n        0 as *mut libc::c_char\n    };\n    url_free(data);\n    return out;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/main.rs:30:1: 30:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/main.rs:28:1: 28:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/main.rs:22:1: 22:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/main.rs:23:1: 23:14 (#0)",
        "source": "use std::str;"
      },
      {
        "span": "src/main.rs:27:1: 27:31 (#0)",
        "source": "use std::ffi::{CStr, CString};"
      },
      {
        "span": "src/main.rs:27:16: 27:20 (#0)",
        "source": "CStr"
      },
      {
        "span": "src/main.rs:27:22: 27:29 (#0)",
        "source": "CString"
      },
      {
        "span": "src/main.rs:25:1: 25:14 (#0)",
        "source": "use std::ptr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:57 ~ oxidate_out[187d]::url_get_host)",
    "span": "src/main.rs:1299:1: 1323:2 (#0)",
    "pieces": [
      "src/main.rs:1299:1: 1323:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "pub unsafe extern \"C\" fn url_get_host(\n    mut url: *const libc::c_char,\n) -> *mut libc::c_char {\n    let mut data = url_parse(url);\n    let mut out = if !data.is_null() && !((*data).host).is_null() {\n        strdup((*data).host)\n    } else {\n        0 as *mut libc::c_char\n    };\n    url_free(data);\n    return out;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/main.rs:27:1: 27:31 (#0)",
        "source": "use std::ffi::{CStr, CString};"
      },
      {
        "span": "src/main.rs:30:1: 30:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/main.rs:28:1: 28:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/main.rs:27:22: 27:29 (#0)",
        "source": "CString"
      },
      {
        "span": "src/main.rs:27:16: 27:20 (#0)",
        "source": "CStr"
      },
      {
        "span": "src/main.rs:23:1: 23:14 (#0)",
        "source": "use std::str;"
      },
      {
        "span": "src/main.rs:22:1: 22:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/main.rs:25:1: 25:14 (#0)",
        "source": "use std::ptr;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:51 ~ oxidate_out[187d]::url_is_protocol)",
    "span": "src/main.rs:1202:1: 1227:2 (#0)",
    "pieces": [
      "src/main.rs:1202:1: 1227:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 14,
    "source": "pub unsafe extern \"C\" fn url_is_protocol(mut str: *const libc::c_char) -> bool {\n    let count = (::core::mem::size_of::<[*const libc::c_char; 177]>() as libc::c_ulong)\n        .wrapping_div(::core::mem::size_of::<*const libc::c_char>() as libc::c_ulong)\n        as libc::c_uint;\n    let mut i = 0 as libc::c_int as libc::c_uint;\n    while i < count {\n        if 0 as libc::c_int == strcmp(URL_SCHEMES[i as usize], str) {\n            return 1 as libc::c_int != 0;\n        }\n        i = i.wrapping_add(1);\n        i;\n    }\n    return 0 as libc::c_int != 0;\n}",
    "calls": [],
    "globals": [
      {
        "span": "src/main.rs:388:1: 566:3 (#0)",
        "source": "static mut URL_SCHEMES: [*const libc::c_char; 177] = [\n    b\"aaa\\0\" as *const u8 as *const libc::c_char,\n    b\"aaas\\0\" as *const u8 as *const libc::c_char,\n    b\"about\\0\" as *const u8 as *const libc::c_char,\n    b\"acap\\0\" as *const u8 as *const libc::c_char,\n    b\"acct\\0\" as *const u8 as *const libc::c_char,\n    b\"adiumxtra\\0\" as *const u8 as *const libc::c_char,\n    b\"afp\\0\" as *const u8 as *const libc::c_char,\n    b\"afs\\0\" as *const u8 as *const libc::c_char,\n    b\"aim\\0\" as *const u8 as *const libc::c_char,\n    b\"apt\\0\" as *const u8 as *const libc::c_char,\n    b\"attachment\\0\" as *const u8 as *const libc::c_char,\n    b\"aw\\0\" as *const u8 as *const libc::c_char,\n    b\"beshare\\0\" as *const u8 as *const libc::c_char,\n    b\"bitcoin\\0\" as *const u8 as *const libc::c_char,\n    b\"bolo\\0\" as *const u8 as *const libc::c_char,\n    b\"callto\\0\" as *const u8 as *const libc::c_char,\n    b\"cap\\0\" as *const u8 as *const libc::c_char,\n    b\"chrome\\0\" as *const u8 as *const libc::c_char,\n    b\"crome-extension\\0\" as *const u8 as *const libc::c_char,\n    b\"com-evenbrite-attendee\\0\" as *const u8 as *const libc::c_char,\n    b\"cid\\0\" as *const u8 as *const libc::c_char,\n    b\"coap\\0\" as *const u8 as *const libc::c_char,\n    b\"coaps\\0\" as *const u8 as *const libc::c_char,\n    b\"content\\0\" as *const u8 as *const libc::c_char,\n    b\"crid\\0\" as *const u8 as *const libc::c_char,\n    b\"cvs\\0\" as *const u8 as *const libc::c_char,\n    b\"data\\0\" as *const u8 as *const libc::c_char,\n    b\"dav\\0\" as *const u8 as *const libc::c_char,\n    b\"dict\\0\" as *const u8 as *const libc::c_char,\n    b\"lna-playsingle\\0\" as *const u8 as *const libc::c_char,\n    b\"dln-playcontainer\\0\" as *const u8 as *const libc::c_char,\n    b\"dns\\0\" as *const u8 as *const libc::c_char,\n    b\"dtn\\0\" as *const u8 as *const libc::c_char,\n    b\"dvb\\0\" as *const u8 as *const libc::c_char,\n    b\"ed2k\\0\" as *const u8 as *const libc::c_char,\n    b\"facetime\\0\" as *const u8 as *const libc::c_char,\n    b\"fax\\0\" as *const u8 as *const libc::c_char,\n    b\"feed\\0\" as *const u8 as *const libc::c_char,\n    b\"file\\0\" as *const u8 as *const libc::c_char,\n    b\"finger\\0\" as *const u8 as *const libc::c_char,\n    b\"fish\\0\" as *const u8 as *const libc::c_char,\n    b\"ftp\\0\" as *const u8 as *const libc::c_char,\n    b\"geo\\0\" as *const u8 as *const libc::c_char,\n    b\"gg\\0\" as *const u8 as *const libc::c_char,\n    b\"git\\0\" as *const u8 as *const libc::c_char,\n    b\"gizmoproject\\0\" as *const u8 as *const libc::c_char,\n    b\"go\\0\" as *const u8 as *const libc::c_char,\n    b\"gopher\\0\" as *const u8 as *const libc::c_char,\n    b\"gtalk\\0\" as *const u8 as *const libc::c_char,\n    b\"h323\\0\" as *const u8 as *const libc::c_char,\n    b\"hcp\\0\" as *const u8 as *const libc::c_char,\n    b\"http\\0\" as *const u8 as *const libc::c_char,\n    b\"https\\0\" as *const u8 as *const libc::c_char,\n    b\"iax\\0\" as *const u8 as *const libc::c_char,\n    b\"icap\\0\" as *const u8 as *const libc::c_char,\n    b\"icon\\0\" as *const u8 as *const libc::c_char,\n    b\"im\\0\" as *const u8 as *const libc::c_char,\n    b\"imap\\0\" as *const u8 as *const libc::c_char,\n    b\"info\\0\" as *const u8 as *const libc::c_char,\n    b\"ipn\\0\" as *const u8 as *const libc::c_char,\n    b\"ipp\\0\" as *const u8 as *const libc::c_char,\n    b\"irc\\0\" as *const u8 as *const libc::c_char,\n    b\"irc6\\0\" as *const u8 as *const libc::c_char,\n    b\"ircs\\0\" as *const u8 as *const libc::c_char,\n    b\"iris\\0\" as *const u8 as *const libc::c_char,\n    b\"iris.beep\\0\" as *const u8 as *const libc::c_char,\n    b\"iris.xpc\\0\" as *const u8 as *const libc::c_char,\n    b\"iris.xpcs\\0\" as *const u8 as *const libc::c_char,\n    b\"iris.lws\\0\" as *const u8 as *const libc::c_char,\n    b\"itms\\0\" as *const u8 as *const libc::c_char,\n    b\"jabber\\0\" as *const u8 as *const libc::c_char,\n    b\"jar\\0\" as *const u8 as *const libc::c_char,\n    b\"jms\\0\" as *const u8 as *const libc::c_char,\n    b\"keyparc\\0\" as *const u8 as *const libc::c_char,\n    b\"lastfm\\0\" as *const u8 as *const libc::c_char,\n    b\"ldap\\0\" as *const u8 as *const libc::c_char,\n    b\"ldaps\\0\" as *const u8 as *const libc::c_char,\n    b\"magnet\\0\" as *const u8 as *const libc::c_char,\n    b\"mailserver\\0\" as *const u8 as *const libc::c_char,\n    b\"mailto\\0\" as *const u8 as *const libc::c_char,\n    b\"maps\\0\" as *const u8 as *const libc::c_char,\n    b\"market\\0\" as *const u8 as *const libc::c_char,\n    b\"message\\0\" as *const u8 as *const libc::c_char,\n    b\"mid\\0\" as *const u8 as *const libc::c_char,\n    b\"mms\\0\" as *const u8 as *const libc::c_char,\n    b\"modem\\0\" as *const u8 as *const libc::c_char,\n    b\"ms-help\\0\" as *const u8 as *const libc::c_char,\n    b\"mssettings-power\\0\" as *const u8 as *const libc::c_char,\n    b\"msnim\\0\" as *const u8 as *const libc::c_char,\n    b\"msrp\\0\" as *const u8 as *const libc::c_char,\n    b\"msrps\\0\" as *const u8 as *const libc::c_char,\n    b\"mtqp\\0\" as *const u8 as *const libc::c_char,\n    b\"mumble\\0\" as *const u8 as *const libc::c_char,\n    b\"mupdate\\0\" as *const u8 as *const libc::c_char,\n    b\"mvn\\0\" as *const u8 as *const libc::c_char,\n    b\"news\\0\" as *const u8 as *const libc::c_char,\n    b\"nfs\\0\" as *const u8 as *const libc::c_char,\n    b\"ni\\0\" as *const u8 as *const libc::c_char,\n    b\"nih\\0\" as *const u8 as *const libc::c_char,\n    b\"nntp\\0\" as *const u8 as *const libc::c_char,\n    b\"notes\\0\" as *const u8 as *const libc::c_char,\n    b\"oid\\0\" as *const u8 as *const libc::c_char,\n    b\"paquelocktoken\\0\" as *const u8 as *const libc::c_char,\n    b\"pack\\0\" as *const u8 as *const libc::c_char,\n    b\"palm\\0\" as *const u8 as *const libc::c_char,\n    b\"paparazzi\\0\" as *const u8 as *const libc::c_char,\n    b\"pkcs11\\0\" as *const u8 as *const libc::c_char,\n    b\"platform\\0\" as *const u8 as *const libc::c_char,\n    b\"pop\\0\" as *const u8 as *const libc::c_char,\n    b\"pres\\0\" as *const u8 as *const libc::c_char,\n    b\"prospero\\0\" as *const u8 as *const libc::c_char,\n    b\"proxy\\0\" as *const u8 as *const libc::c_char,\n    b\"psyc\\0\" as *const u8 as *const libc::c_char,\n    b\"query\\0\" as *const u8 as *const libc::c_char,\n    b\"reload\\0\" as *const u8 as *const libc::c_char,\n    b\"res\\0\" as *const u8 as *const libc::c_char,\n    b\"resource\\0\" as *const u8 as *const libc::c_char,\n    b\"rmi\\0\" as *const u8 as *const libc::c_char,\n    b\"rsync\\0\" as *const u8 as *const libc::c_char,\n    b\"rtmp\\0\" as *const u8 as *const libc::c_char,\n    b\"rtsp\\0\" as *const u8 as *const libc::c_char,\n    b\"secondlife\\0\" as *const u8 as *const libc::c_char,\n    b\"service\\0\" as *const u8 as *const libc::c_char,\n    b\"session\\0\" as *const u8 as *const libc::c_char,\n    b\"sftp\\0\" as *const u8 as *const libc::c_char,\n    b\"sgn\\0\" as *const u8 as *const libc::c_char,\n    b\"shttp\\0\" as *const u8 as *const libc::c_char,\n    b\"sieve\\0\" as *const u8 as *const libc::c_char,\n    b\"sip\\0\" as *const u8 as *const libc::c_char,\n    b\"sips\\0\" as *const u8 as *const libc::c_char,\n    b\"skype\\0\" as *const u8 as *const libc::c_char,\n    b\"smb\\0\" as *const u8 as *const libc::c_char,\n    b\"sms\\0\" as *const u8 as *const libc::c_char,\n    b\"snews\\0\" as *const u8 as *const libc::c_char,\n    b\"snmp\\0\" as *const u8 as *const libc::c_char,\n    b\"soap.beep\\0\" as *const u8 as *const libc::c_char,\n    b\"soap.beeps\\0\" as *const u8 as *const libc::c_char,\n    b\"soldat\\0\" as *const u8 as *const libc::c_char,\n    b\"spotify\\0\" as *const u8 as *const libc::c_char,\n    b\"ssh\\0\" as *const u8 as *const libc::c_char,\n    b\"steam\\0\" as *const u8 as *const libc::c_char,\n    b\"svn\\0\" as *const u8 as *const libc::c_char,\n    b\"tag\\0\" as *const u8 as *const libc::c_char,\n    b\"teamspeak\\0\" as *const u8 as *const libc::c_char,\n    b\"tel\\0\" as *const u8 as *const libc::c_char,\n    b\"telnet\\0\" as *const u8 as *const libc::c_char,\n    b\"tftp\\0\" as *const u8 as *const libc::c_char,\n    b\"things\\0\" as *const u8 as *const libc::c_char,\n    b\"thismessage\\0\" as *const u8 as *const libc::c_char,\n    b\"tn3270\\0\" as *const u8 as *const libc::c_char,\n    b\"tip\\0\" as *const u8 as *const libc::c_char,\n    b\"tv\\0\" as *const u8 as *const libc::c_char,\n    b\"udp\\0\" as *const u8 as *const libc::c_char,\n    b\"unreal\\0\" as *const u8 as *const libc::c_char,\n    b\"urn\\0\" as *const u8 as *const libc::c_char,\n    b\"ut2004\\0\" as *const u8 as *const libc::c_char,\n    b\"vemmi\\0\" as *const u8 as *const libc::c_char,\n    b\"ventrilo\\0\" as *const u8 as *const libc::c_char,\n    b\"videotex\\0\" as *const u8 as *const libc::c_char,\n    b\"view-source\\0\" as *const u8 as *const libc::c_char,\n    b\"wais\\0\" as *const u8 as *const libc::c_char,\n    b\"webcal\\0\" as *const u8 as *const libc::c_char,\n    b\"ws\\0\" as *const u8 as *const libc::c_char,\n    b\"wss\\0\" as *const u8 as *const libc::c_char,\n    b\"wtai\\0\" as *const u8 as *const libc::c_char,\n    b\"wyciwyg\\0\" as *const u8 as *const libc::c_char,\n    b\"xcon\\0\" as *const u8 as *const libc::c_char,\n    b\"xcon-userid\\0\" as *const u8 as *const libc::c_char,\n    b\"xfire\\0\" as *const u8 as *const libc::c_char,\n    b\"xmlrpc.beep\\0\" as *const u8 as *const libc::c_char,\n    b\"xmlrpc.beeps\\0\" as *const u8 as *const libc::c_char,\n    b\"xmpp\\0\" as *const u8 as *const libc::c_char,\n    b\"xri\\0\" as *const u8 as *const libc::c_char,\n    b\"ymsgr\\0\" as *const u8 as *const libc::c_char,\n    b\"javascript\\0\" as *const u8 as *const libc::c_char,\n    b\"jdbc\\0\" as *const u8 as *const libc::c_char,\n    b\"doi\\0\" as *const u8 as *const libc::c_char,\n];"
      }
    ],
    "imports": [
      {
        "span": "src/main.rs:30:1: 30:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/main.rs:22:1: 22:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/main.rs:25:1: 25:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/main.rs:27:22: 27:29 (#0)",
        "source": "CString"
      },
      {
        "span": "src/main.rs:27:1: 27:31 (#0)",
        "source": "use std::ffi::{CStr, CString};"
      },
      {
        "span": "src/main.rs:27:16: 27:20 (#0)",
        "source": "CStr"
      },
      {
        "span": "src/main.rs:28:1: 28:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/main.rs:23:1: 23:14 (#0)",
        "source": "use std::str;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:38 ~ oxidate_out[187d]::url_get_protocol)",
    "span": "src/main.rs:121:1: 123:2 (#0)",
    "pieces": [
      "src/main.rs:121:1: 123:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 5,
    "source": "unsafe extern \"C\" fn url_get_protocol(\n    mut url: *const libc::c_char,\n) -> *mut libc::c_char {\n    return url_get_scheme(url);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/main.rs:27:1: 27:31 (#0)",
        "source": "use std::ffi::{CStr, CString};"
      },
      {
        "span": "src/main.rs:23:1: 23:14 (#0)",
        "source": "use std::str;"
      },
      {
        "span": "src/main.rs:22:1: 22:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/main.rs:30:1: 30:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/main.rs:28:1: 28:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/main.rs:27:22: 27:29 (#0)",
        "source": "CString"
      },
      {
        "span": "src/main.rs:25:1: 25:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/main.rs:27:16: 27:20 (#0)",
        "source": "CStr"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:45 ~ oxidate_out[187d]::unhex)",
    "span": "src/main.rs:576:1: 593:2 (#0)",
    "pieces": [
      "src/main.rs:576:1: 593:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 12,
    "source": "unsafe extern \"C\" fn unhex(mut s: *const libc::c_char) -> libc::c_int {\n    if *s as libc::c_int >= '0' as i32 && *s as libc::c_int <= '9' as i32 {\n        return *s as libc::c_int - '0' as i32;\n    }\n    if *s as libc::c_int >= 'A' as i32 && *s as libc::c_int <= 'F' as i32 {\n        return *s as libc::c_int - 'A' as i32 + 10 as libc::c_int;\n    }\n    if *s as libc::c_int >= 'a' as i32 && *s as libc::c_int <= 'f' as i32 {\n        return *s as libc::c_int - 'a' as i32 + 10 as libc::c_int;\n    }\n    return -(1 as libc::c_int);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/main.rs:27:22: 27:29 (#0)",
        "source": "CString"
      },
      {
        "span": "src/main.rs:30:1: 30:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/main.rs:22:1: 22:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/main.rs:28:1: 28:25 (#0)",
        "source": "use std::string::String;"
      },
      {
        "span": "src/main.rs:25:1: 25:14 (#0)",
        "source": "use std::ptr;"
      },
      {
        "span": "src/main.rs:27:16: 27:20 (#0)",
        "source": "CStr"
      },
      {
        "span": "src/main.rs:23:1: 23:14 (#0)",
        "source": "use std::str;"
      },
      {
        "span": "src/main.rs:27:1: 27:31 (#0)",
        "source": "use std::ffi::{CStr, CString};"
      }
    ],
    "chunks": []
  }
]