[
  {
    "func_defid": "DefId(0:58 ~ oxidate_out[187d]::csv_write2)",
    "span": "src/main.rs:844:1: 886:2 (#0)",
    "pieces": [
      "src/main.rs:844:1: 886:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 58,
    "source": "pub unsafe extern \"C\" fn csv_write2(\n    mut dest: *mut libc::c_void,\n    mut dest_size: size_t,\n    mut src: *const libc::c_void,\n    mut src_size: size_t,\n    mut quote: libc::c_uchar,\n) -> size_t {\n    let mut cdest = dest as *mut libc::c_uchar;\n    let mut csrc = src as *const libc::c_uchar;\n    let mut chars = 0 as libc::c_int as size_t;\n    if src.is_null() {\n        return 0 as libc::c_int as size_t;\n    }\n    if dest.is_null() {\n        dest_size = 0 as libc::c_int as size_t;\n    }\n    if dest_size > 0 as libc::c_int as libc::c_ulong {\n        let fresh11 = cdest;\n        cdest = cdest.offset(1);\n        *fresh11 = quote;\n    }\n    chars = chars.wrapping_add(1);\n    chars;\n    while src_size != 0 {\n        if *csrc as libc::c_int == quote as libc::c_int {\n            if dest_size > chars {\n                let fresh12 = cdest;\n                cdest = cdest.offset(1);\n                *fresh12 = quote;\n            }\n            if chars < 18446744073709551615 as libc::c_ulong {\n                chars = chars.wrapping_add(1);\n                chars;\n            }\n        }\n        if dest_size > chars {\n            let fresh13 = cdest;\n            cdest = cdest.offset(1);\n            *fresh13 = *csrc;\n        }\n        if chars < 18446744073709551615 as libc::c_ulong {\n            chars = chars.wrapping_add(1);\n            chars;\n        }\n        src_size = src_size.wrapping_sub(1);\n        src_size;\n        csrc = csrc.offset(1);\n        csrc;\n    }\n    if dest_size > chars {\n        *cdest = quote;\n    }\n    if chars < 18446744073709551615 as libc::c_ulong {\n        chars = chars.wrapping_add(1);\n        chars;\n    }\n    return chars;\n}",
    "calls": [
      {
        "caller": "DefId(0:66 ~ oxidate_out[187d]::csv_write)",
        "span": "src/main.rs:832:56: 835:2 (#0)",
        "source": "{\n    // 0x22 is the ASCII code for the double quote character (\")\n    csv_write2(Some(dest), src, b'\"').try_into().unwrap()\n}"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/main.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/main.rs:30:1: 30:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/main.rs:19:1: 19:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/main.rs:23:1: 23:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/main.rs:27:1: 27:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/main.rs:21:15: 21:19 (#0)",
        "source": "self"
      },
      {
        "span": "src/main.rs:25:1: 25:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/main.rs:21:1: 21:28 (#0)",
        "source": "use std::io::{self, Write};"
      },
      {
        "span": "src/main.rs:21:21: 21:26 (#0)",
        "source": "Write"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:56 ~ oxidate_out[187d]::csv_write)",
    "span": "src/main.rs:832:1: 835:2 (#0)",
    "pieces": [
      "src/main.rs:832:1: 835:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 14,
    "source": "pub unsafe extern \"C\" fn csv_write(\n    mut dest: *mut libc::c_void,\n    mut dest_size: size_t,\n    mut src: *const libc::c_void,\n    mut src_size: size_t,\n) -> size_t {\n    return csv_write2(\n        dest,\n        dest_size,\n        src,\n        src_size,\n        0x22 as libc::c_int as libc::c_uchar,\n    );\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/main.rs:27:1: 27:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/main.rs:21:21: 21:26 (#0)",
        "source": "Write"
      },
      {
        "span": "src/main.rs:21:15: 21:19 (#0)",
        "source": "self"
      },
      {
        "span": "src/main.rs:25:1: 25:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/main.rs:19:1: 19:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/main.rs:23:1: 23:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/main.rs:30:1: 30:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/main.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/main.rs:21:1: 21:28 (#0)",
        "source": "use std::io::{self, Write};"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:45 ~ oxidate_out[187d]::csv_set_term_func)",
    "span": "src/main.rs:300:1: 304:2 (#0)",
    "pieces": [
      "src/main.rs:300:1: 304:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "pub unsafe extern \"C\" fn csv_set_term_func(\n    mut p: *mut csv_parser,\n    mut f: Option::<unsafe extern \"C\" fn(libc::c_uchar) -> libc::c_int>,\n) {\n    if !p.is_null() {\n        (*p).is_term = f;\n    }\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/main.rs:23:1: 23:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/main.rs:25:1: 25:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/main.rs:19:1: 19:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/main.rs:21:1: 21:28 (#0)",
        "source": "use std::io::{self, Write};"
      },
      {
        "span": "src/main.rs:27:1: 27:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/main.rs:21:21: 21:26 (#0)",
        "source": "Write"
      },
      {
        "span": "src/main.rs:21:15: 21:19 (#0)",
        "source": "self"
      },
      {
        "span": "src/main.rs:30:1: 30:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/main.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:34 ~ oxidate_out[187d]::csv_get_delim)",
    "span": "src/main.rs:283:1: 285:2 (#0)",
    "pieces": [
      "src/main.rs:283:1: 285:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 36,
    "source": "pub unsafe extern \"C\" fn csv_get_delim(mut p: *const csv_parser) -> libc::c_uchar {\n    if !p.is_null()\n        && !(b\"received null csv_parser\\0\" as *const u8 as *const libc::c_char).is_null()\n    {} else {\n        __assert_fail(\n            b\"p && \\\"received null csv_parser\\\"\\0\" as *const u8 as *const libc::c_char,\n            b\"/workspace/programs/libcsv/libcsv.c\\0\" as *const u8 as *const libc::c_char,\n            222 as libc::c_int as libc::c_uint,\n            (*::core::mem::transmute::<\n                &[u8; 55],\n                &[libc::c_char; 55],\n            >(b\"unsigned char csv_get_delim(const struct csv_parser *)\\0\"))\n                .as_ptr(),\n        );\n    }\n    'c_4256: {\n        if !p.is_null()\n            && !(b\"received null csv_parser\\0\" as *const u8 as *const libc::c_char)\n                .is_null()\n        {} else {\n            __assert_fail(\n                b\"p && \\\"received null csv_parser\\\"\\0\" as *const u8\n                    as *const libc::c_char,\n                b\"/workspace/programs/libcsv/libcsv.c\\0\" as *const u8\n                    as *const libc::c_char,\n                222 as libc::c_int as libc::c_uint,\n                (*::core::mem::transmute::<\n                    &[u8; 55],\n                    &[libc::c_char; 55],\n                >(b\"unsigned char csv_get_delim(const struct csv_parser *)\\0\"))\n                    .as_ptr(),\n            );\n        }\n    };\n    return (*p).delim_char;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/main.rs:19:1: 19:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/main.rs:21:1: 21:28 (#0)",
        "source": "use std::io::{self, Write};"
      },
      {
        "span": "src/main.rs:21:15: 21:19 (#0)",
        "source": "self"
      },
      {
        "span": "src/main.rs:21:21: 21:26 (#0)",
        "source": "Write"
      },
      {
        "span": "src/main.rs:27:1: 27:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/main.rs:23:1: 23:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/main.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/main.rs:30:1: 30:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/main.rs:25:1: 25:26 (#0)",
        "source": "use std::os::raw::c_void;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:60 ~ oxidate_out[187d]::main)",
    "span": "src/main.rs:935:1: 937:2 (#0)",
    "pieces": [
      "src/main.rs:935:1: 937:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 1,
    "source": "pub fn main(){}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/main.rs:27:1: 27:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/main.rs:21:21: 21:26 (#0)",
        "source": "Write"
      },
      {
        "span": "src/main.rs:19:1: 19:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/main.rs:21:15: 21:19 (#0)",
        "source": "self"
      },
      {
        "span": "src/main.rs:21:1: 21:28 (#0)",
        "source": "use std::io::{self, Write};"
      },
      {
        "span": "src/main.rs:25:1: 25:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/main.rs:30:1: 30:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/main.rs:23:1: 23:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/main.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:39 ~ oxidate_out[187d]::csv_get_quote)",
    "span": "src/main.rs:288:1: 290:2 (#0)",
    "pieces": [
      "src/main.rs:288:1: 290:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 36,
    "source": "pub unsafe extern \"C\" fn csv_get_quote(mut p: *const csv_parser) -> libc::c_uchar {\n    if !p.is_null()\n        && !(b\"received null csv_parser\\0\" as *const u8 as *const libc::c_char).is_null()\n    {} else {\n        __assert_fail(\n            b\"p && \\\"received null csv_parser\\\"\\0\" as *const u8 as *const libc::c_char,\n            b\"/workspace/programs/libcsv/libcsv.c\\0\" as *const u8 as *const libc::c_char,\n            231 as libc::c_int as libc::c_uint,\n            (*::core::mem::transmute::<\n                &[u8; 55],\n                &[libc::c_char; 55],\n            >(b\"unsigned char csv_get_quote(const struct csv_parser *)\\0\"))\n                .as_ptr(),\n        );\n    }\n    'c_4304: {\n        if !p.is_null()\n            && !(b\"received null csv_parser\\0\" as *const u8 as *const libc::c_char)\n                .is_null()\n        {} else {\n            __assert_fail(\n                b\"p && \\\"received null csv_parser\\\"\\0\" as *const u8\n                    as *const libc::c_char,\n                b\"/workspace/programs/libcsv/libcsv.c\\0\" as *const u8\n                    as *const libc::c_char,\n                231 as libc::c_int as libc::c_uint,\n                (*::core::mem::transmute::<\n                    &[u8; 55],\n                    &[libc::c_char; 55],\n                >(b\"unsigned char csv_get_quote(const struct csv_parser *)\\0\"))\n                    .as_ptr(),\n            );\n        }\n    };\n    return (*p).quote_char;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/main.rs:27:1: 27:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/main.rs:30:1: 30:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/main.rs:21:21: 21:26 (#0)",
        "source": "Write"
      },
      {
        "span": "src/main.rs:23:1: 23:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/main.rs:25:1: 25:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/main.rs:21:1: 21:28 (#0)",
        "source": "use std::io::{self, Write};"
      },
      {
        "span": "src/main.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/main.rs:19:1: 19:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/main.rs:21:15: 21:19 (#0)",
        "source": "self"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:47 ~ oxidate_out[187d]::csv_set_free_func)",
    "span": "src/main.rs:317:1: 321:2 (#0)",
    "pieces": [
      "src/main.rs:317:1: 321:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "pub unsafe extern \"C\" fn csv_set_free_func(\n    mut p: *mut csv_parser,\n    mut f: Option::<unsafe extern \"C\" fn(*mut libc::c_void) -> ()>,\n) {\n    if !p.is_null() && f.is_some() {\n        (*p).free_func = f;\n    }\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/main.rs:21:15: 21:19 (#0)",
        "source": "self"
      },
      {
        "span": "src/main.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/main.rs:21:21: 21:26 (#0)",
        "source": "Write"
      },
      {
        "span": "src/main.rs:21:1: 21:28 (#0)",
        "source": "use std::io::{self, Write};"
      },
      {
        "span": "src/main.rs:23:1: 23:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/main.rs:25:1: 25:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/main.rs:19:1: 19:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/main.rs:30:1: 30:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/main.rs:27:1: 27:16 (#0)",
        "source": "use std::slice;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:27 ~ oxidate_out[187d]::csv_get_opts)",
    "span": "src/main.rs:136:1: 141:2 (#0)",
    "pieces": [
      "src/main.rs:136:1: 141:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn csv_get_opts(mut p: *const csv_parser) -> libc::c_int {\n    if p.is_null() {\n        return -(1 as libc::c_int);\n    }\n    return (*p).options as libc::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/main.rs:21:15: 21:19 (#0)",
        "source": "self"
      },
      {
        "span": "src/main.rs:21:1: 21:28 (#0)",
        "source": "use std::io::{self, Write};"
      },
      {
        "span": "src/main.rs:25:1: 25:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/main.rs:23:1: 23:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/main.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/main.rs:21:21: 21:26 (#0)",
        "source": "Write"
      },
      {
        "span": "src/main.rs:27:1: 27:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/main.rs:30:1: 30:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/main.rs:19:1: 19:14 (#0)",
        "source": "use std::mem;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:26 ~ oxidate_out[187d]::csv_strerror)",
    "span": "src/main.rs:120:1: 133:2 (#0)",
    "pieces": [
      "src/main.rs:120:1: 133:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn csv_strerror(mut status: libc::c_int) -> *const libc::c_char {\n    if status >= 4 as libc::c_int || status < 0 as libc::c_int {\n        return csv_errors[4 as libc::c_int as usize]\n    } else {\n        return csv_errors[status as usize]\n    };\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/main.rs:21:21: 21:26 (#0)",
        "source": "Write"
      },
      {
        "span": "src/main.rs:25:1: 25:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/main.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/main.rs:19:1: 19:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/main.rs:21:1: 21:28 (#0)",
        "source": "use std::io::{self, Write};"
      },
      {
        "span": "src/main.rs:30:1: 30:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/main.rs:23:1: 23:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/main.rs:27:1: 27:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/main.rs:21:15: 21:19 (#0)",
        "source": "self"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:33 ~ oxidate_out[187d]::csv_set_quote)",
    "span": "src/main.rs:278:1: 280:2 (#0)",
    "pieces": [
      "src/main.rs:278:1: 280:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 5,
    "source": "pub unsafe extern \"C\" fn csv_set_quote(mut p: *mut csv_parser, mut c: libc::c_uchar) {\n    if !p.is_null() {\n        (*p).quote_char = c;\n    }\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/main.rs:21:15: 21:19 (#0)",
        "source": "self"
      },
      {
        "span": "src/main.rs:23:1: 23:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/main.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/main.rs:21:21: 21:26 (#0)",
        "source": "Write"
      },
      {
        "span": "src/main.rs:25:1: 25:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/main.rs:27:1: 27:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/main.rs:19:1: 19:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/main.rs:21:1: 21:28 (#0)",
        "source": "use std::io::{self, Write};"
      },
      {
        "span": "src/main.rs:30:1: 30:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:48 ~ oxidate_out[187d]::csv_set_blk_size)",
    "span": "src/main.rs:324:1: 328:2 (#0)",
    "pieces": [
      "src/main.rs:324:1: 328:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 5,
    "source": "pub unsafe extern \"C\" fn csv_set_blk_size(mut p: *mut csv_parser, mut size: size_t) {\n    if !p.is_null() {\n        (*p).blk_size = size;\n    }\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/main.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/main.rs:21:15: 21:19 (#0)",
        "source": "self"
      },
      {
        "span": "src/main.rs:30:1: 30:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/main.rs:27:1: 27:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/main.rs:25:1: 25:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/main.rs:19:1: 19:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/main.rs:21:1: 21:28 (#0)",
        "source": "use std::io::{self, Write};"
      },
      {
        "span": "src/main.rs:23:1: 23:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/main.rs:21:21: 21:26 (#0)",
        "source": "Write"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:29 ~ oxidate_out[187d]::csv_init)",
    "span": "src/main.rs:150:1: 168:2 (#0)",
    "pieces": [
      "src/main.rs:150:1: 168:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 32,
    "source": "pub unsafe extern \"C\" fn csv_init(\n    mut p: *mut csv_parser,\n    mut options: libc::c_uchar,\n) -> libc::c_int {\n    if p.is_null() {\n        return -(1 as libc::c_int);\n    }\n    (*p).entry_buf = 0 as *mut libc::c_uchar;\n    (*p).pstate = 0 as libc::c_int;\n    (*p).quoted = 0 as libc::c_int;\n    (*p).spaces = 0 as libc::c_int as size_t;\n    (*p).entry_pos = 0 as libc::c_int as size_t;\n    (*p).entry_size = 0 as libc::c_int as size_t;\n    (*p).status = 0 as libc::c_int;\n    (*p).options = options;\n    (*p).quote_char = 0x22 as libc::c_int as libc::c_uchar;\n    (*p).delim_char = 0x2c as libc::c_int as libc::c_uchar;\n    (*p).is_space = None;\n    (*p).is_term = None;\n    (*p).blk_size = 128 as libc::c_int as size_t;\n    (*p).malloc_func = None;\n    (*p)\n        .realloc_func = Some(\n        realloc\n            as unsafe extern \"C\" fn(\n                *mut libc::c_void,\n                libc::c_ulong,\n            ) -> *mut libc::c_void,\n    );\n    (*p).free_func = Some(free as unsafe extern \"C\" fn(*mut libc::c_void) -> ());\n    return 0 as libc::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/main.rs:30:1: 30:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/main.rs:21:15: 21:19 (#0)",
        "source": "self"
      },
      {
        "span": "src/main.rs:19:1: 19:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/main.rs:23:1: 23:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/main.rs:21:1: 21:28 (#0)",
        "source": "use std::io::{self, Write};"
      },
      {
        "span": "src/main.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/main.rs:27:1: 27:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/main.rs:21:21: 21:26 (#0)",
        "source": "Write"
      },
      {
        "span": "src/main.rs:25:1: 25:26 (#0)",
        "source": "use std::os::raw::c_void;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:46 ~ oxidate_out[187d]::csv_set_realloc_func)",
    "span": "src/main.rs:307:1: 314:2 (#0)",
    "pieces": [
      "src/main.rs:307:1: 314:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "pub unsafe extern \"C\" fn csv_set_realloc_func(\n    mut p: *mut csv_parser,\n    mut f: Option::<unsafe extern \"C\" fn(*mut libc::c_void, size_t) -> *mut libc::c_void>,\n) {\n    if !p.is_null() && f.is_some() {\n        (*p).realloc_func = f;\n    }\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/main.rs:21:15: 21:19 (#0)",
        "source": "self"
      },
      {
        "span": "src/main.rs:23:1: 23:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/main.rs:27:1: 27:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/main.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/main.rs:21:21: 21:26 (#0)",
        "source": "Write"
      },
      {
        "span": "src/main.rs:25:1: 25:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/main.rs:30:1: 30:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/main.rs:21:1: 21:28 (#0)",
        "source": "use std::io::{self, Write};"
      },
      {
        "span": "src/main.rs:19:1: 19:14 (#0)",
        "source": "use std::mem;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:32 ~ oxidate_out[187d]::csv_set_delim)",
    "span": "src/main.rs:271:1: 275:2 (#0)",
    "pieces": [
      "src/main.rs:271:1: 275:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 5,
    "source": "pub unsafe extern \"C\" fn csv_set_delim(mut p: *mut csv_parser, mut c: libc::c_uchar) {\n    if !p.is_null() {\n        (*p).delim_char = c;\n    }\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/main.rs:23:1: 23:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/main.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/main.rs:25:1: 25:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/main.rs:30:1: 30:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/main.rs:21:15: 21:19 (#0)",
        "source": "self"
      },
      {
        "span": "src/main.rs:19:1: 19:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/main.rs:21:21: 21:26 (#0)",
        "source": "Write"
      },
      {
        "span": "src/main.rs:21:1: 21:28 (#0)",
        "source": "use std::io::{self, Write};"
      },
      {
        "span": "src/main.rs:27:1: 27:16 (#0)",
        "source": "use std::slice;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:21 ~ oxidate_out[187d]::csv_error)",
    "span": "src/main.rs:115:1: 117:2 (#0)",
    "pieces": [
      "src/main.rs:115:1: 117:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 36,
    "source": "pub unsafe extern \"C\" fn csv_error(mut p: *const csv_parser) -> libc::c_int {\n    if !p.is_null()\n        && !(b\"received null csv_parser\\0\" as *const u8 as *const libc::c_char).is_null()\n    {} else {\n        __assert_fail(\n            b\"p && \\\"received null csv_parser\\\"\\0\" as *const u8 as *const libc::c_char,\n            b\"/workspace/programs/libcsv/libcsv.c\\0\" as *const u8 as *const libc::c_char,\n            82 as libc::c_int as libc::c_uint,\n            (*::core::mem::transmute::<\n                &[u8; 41],\n                &[libc::c_char; 41],\n            >(b\"int csv_error(const struct csv_parser *)\\0\"))\n                .as_ptr(),\n        );\n    }\n    'c_2019: {\n        if !p.is_null()\n            && !(b\"received null csv_parser\\0\" as *const u8 as *const libc::c_char)\n                .is_null()\n        {} else {\n            __assert_fail(\n                b\"p && \\\"received null csv_parser\\\"\\0\" as *const u8\n                    as *const libc::c_char,\n                b\"/workspace/programs/libcsv/libcsv.c\\0\" as *const u8\n                    as *const libc::c_char,\n                82 as libc::c_int as libc::c_uint,\n                (*::core::mem::transmute::<\n                    &[u8; 41],\n                    &[libc::c_char; 41],\n                >(b\"int csv_error(const struct csv_parser *)\\0\"))\n                    .as_ptr(),\n            );\n        }\n    };\n    return (*p).status;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/main.rs:25:1: 25:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/main.rs:21:15: 21:19 (#0)",
        "source": "self"
      },
      {
        "span": "src/main.rs:21:1: 21:28 (#0)",
        "source": "use std::io::{self, Write};"
      },
      {
        "span": "src/main.rs:19:1: 19:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/main.rs:30:1: 30:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/main.rs:23:1: 23:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/main.rs:21:21: 21:26 (#0)",
        "source": "Write"
      },
      {
        "span": "src/main.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/main.rs:27:1: 27:16 (#0)",
        "source": "use std::slice;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:44 ~ oxidate_out[187d]::csv_set_space_func)",
    "span": "src/main.rs:293:1: 297:2 (#0)",
    "pieces": [
      "src/main.rs:293:1: 297:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 8,
    "source": "pub unsafe extern \"C\" fn csv_set_space_func(\n    mut p: *mut csv_parser,\n    mut f: Option::<unsafe extern \"C\" fn(libc::c_uchar) -> libc::c_int>,\n) {\n    if !p.is_null() {\n        (*p).is_space = f;\n    }\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/main.rs:21:21: 21:26 (#0)",
        "source": "Write"
      },
      {
        "span": "src/main.rs:25:1: 25:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/main.rs:27:1: 27:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/main.rs:23:1: 23:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/main.rs:30:1: 30:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/main.rs:21:15: 21:19 (#0)",
        "source": "self"
      },
      {
        "span": "src/main.rs:19:1: 19:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/main.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/main.rs:21:1: 21:28 (#0)",
        "source": "use std::io::{self, Write};"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:28 ~ oxidate_out[187d]::csv_set_opts)",
    "span": "src/main.rs:144:1: 147:2 (#0)",
    "pieces": [
      "src/main.rs:144:1: 147:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 10,
    "source": "pub unsafe extern \"C\" fn csv_set_opts(\n    mut p: *mut csv_parser,\n    mut options: libc::c_uchar,\n) -> libc::c_int {\n    if p.is_null() {\n        return -(1 as libc::c_int);\n    }\n    (*p).options = options;\n    return 0 as libc::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/main.rs:27:1: 27:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/main.rs:23:1: 23:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/main.rs:21:15: 21:19 (#0)",
        "source": "self"
      },
      {
        "span": "src/main.rs:25:1: 25:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/main.rs:19:1: 19:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/main.rs:21:1: 21:28 (#0)",
        "source": "use std::io::{self, Write};"
      },
      {
        "span": "src/main.rs:30:1: 30:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/main.rs:21:21: 21:26 (#0)",
        "source": "Write"
      },
      {
        "span": "src/main.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:59 ~ oxidate_out[187d]::csv_fwrite2)",
    "span": "src/main.rs:889:1: 932:2 (#0)",
    "pieces": [
      "src/main.rs:889:1: 932:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 32,
    "source": "pub unsafe extern \"C\" fn csv_fwrite2(\n    mut fp: *mut FILE,\n    mut src: *const libc::c_void,\n    mut src_size: size_t,\n    mut quote: libc::c_uchar,\n) -> libc::c_int {\n    let mut csrc = src as *const libc::c_uchar;\n    if fp.is_null() || src.is_null() {\n        return 0 as libc::c_int;\n    }\n    if fputc(quote as libc::c_int, fp) == -(1 as libc::c_int) {\n        return -(1 as libc::c_int);\n    }\n    while src_size != 0 {\n        if *csrc as libc::c_int == quote as libc::c_int {\n            if fputc(quote as libc::c_int, fp) == -(1 as libc::c_int) {\n                return -(1 as libc::c_int);\n            }\n        }\n        if fputc(*csrc as libc::c_int, fp) == -(1 as libc::c_int) {\n            return -(1 as libc::c_int);\n        }\n        src_size = src_size.wrapping_sub(1);\n        src_size;\n        csrc = csrc.offset(1);\n        csrc;\n    }\n    if fputc(quote as libc::c_int, fp) == -(1 as libc::c_int) {\n        return -(1 as libc::c_int);\n    }\n    return 0 as libc::c_int;\n}",
    "calls": [
      {
        "caller": "DefId(0:67 ~ oxidate_out[187d]::csv_fwrite)",
        "span": "src/main.rs:838:76: 841:2 (#0)",
        "source": "{\n    // 0x22 is the ASCII code for the double quote, now given as 34u8.\n    csv_fwrite2(fp, src, 34u8)\n}"
      }
    ],
    "globals": [],
    "imports": [
      {
        "span": "src/main.rs:21:21: 21:26 (#0)",
        "source": "Write"
      },
      {
        "span": "src/main.rs:27:1: 27:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/main.rs:21:1: 21:28 (#0)",
        "source": "use std::io::{self, Write};"
      },
      {
        "span": "src/main.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/main.rs:30:1: 30:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/main.rs:21:15: 21:19 (#0)",
        "source": "self"
      },
      {
        "span": "src/main.rs:19:1: 19:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/main.rs:25:1: 25:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/main.rs:23:1: 23:24 (#0)",
        "source": "use std::ptr::null_mut;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:57 ~ oxidate_out[187d]::csv_fwrite)",
    "span": "src/main.rs:838:1: 841:2 (#0)",
    "pieces": [
      "src/main.rs:838:1: 841:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 7,
    "source": "pub unsafe extern \"C\" fn csv_fwrite(\n    mut fp: *mut FILE,\n    mut src: *const libc::c_void,\n    mut src_size: size_t,\n) -> libc::c_int {\n    return csv_fwrite2(fp, src, src_size, 0x22 as libc::c_int as libc::c_uchar);\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/main.rs:19:1: 19:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/main.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/main.rs:21:15: 21:19 (#0)",
        "source": "self"
      },
      {
        "span": "src/main.rs:27:1: 27:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/main.rs:30:1: 30:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/main.rs:25:1: 25:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/main.rs:23:1: 23:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/main.rs:21:1: 21:28 (#0)",
        "source": "use std::io::{self, Write};"
      },
      {
        "span": "src/main.rs:21:21: 21:26 (#0)",
        "source": "Write"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:31 ~ oxidate_out[187d]::csv_fini)",
    "span": "src/main.rs:186:1: 269:2 (#0)",
    "pieces": [
      "src/main.rs:186:1: 269:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 84,
    "source": "pub unsafe extern \"C\" fn csv_fini(\n    mut p: *mut csv_parser,\n    mut cb1: Option::<\n        unsafe extern \"C\" fn(*mut libc::c_void, size_t, *mut libc::c_void) -> (),\n    >,\n    mut cb2: Option::<unsafe extern \"C\" fn(libc::c_int, *mut libc::c_void) -> ()>,\n    mut data: *mut libc::c_void,\n) -> libc::c_int {\n    if p.is_null() {\n        return -(1 as libc::c_int);\n    }\n    let mut quoted = (*p).quoted;\n    let mut pstate = (*p).pstate;\n    let mut spaces = (*p).spaces;\n    let mut entry_pos = (*p).entry_pos;\n    if pstate == 2 as libc::c_int && (*p).quoted != 0\n        && (*p).options as libc::c_int & 1 as libc::c_int != 0\n        && (*p).options as libc::c_int & 4 as libc::c_int != 0\n    {\n        (*p).status = 1 as libc::c_int;\n        return -(1 as libc::c_int);\n    }\n    let mut current_block_26: u64;\n    match pstate {\n        3 => {\n            (*p)\n                .entry_pos = ((*p).entry_pos as libc::c_ulong)\n                .wrapping_sub(\n                    ((*p).spaces).wrapping_add(1 as libc::c_int as libc::c_ulong),\n                ) as size_t as size_t;\n            entry_pos = (*p).entry_pos;\n            current_block_26 = 186392437941418340;\n        }\n        1 | 2 => {\n            current_block_26 = 186392437941418340;\n        }\n        0 | _ => {\n            current_block_26 = 15768484401365413375;\n        }\n    }\n    match current_block_26 {\n        186392437941418340 => {\n            if quoted == 0 {\n                entry_pos = (entry_pos as libc::c_ulong).wrapping_sub(spaces) as size_t\n                    as size_t;\n            }\n            if (*p).options as libc::c_int & 8 as libc::c_int != 0 {\n                *((*p).entry_buf)\n                    .offset(entry_pos as isize) = '\\0' as i32 as libc::c_uchar;\n            }\n            if cb1.is_some() && (*p).options as libc::c_int & 16 as libc::c_int != 0\n                && quoted == 0 && entry_pos == 0 as libc::c_int as libc::c_ulong\n            {\n                cb1\n                    .expect(\n                        \"non-null function pointer\",\n                    )(0 as *mut libc::c_void, entry_pos, data);\n            } else if cb1.is_some() {\n                cb1\n                    .expect(\n                        \"non-null function pointer\",\n                    )((*p).entry_buf as *mut libc::c_void, entry_pos, data);\n            }\n            pstate = 1 as libc::c_int;\n            spaces = 0 as libc::c_int as size_t;\n            quoted = spaces as libc::c_int;\n            entry_pos = quoted as size_t;\n            if cb2.is_some() {\n                cb2.expect(\"non-null function pointer\")(-(1 as libc::c_int), data);\n            }\n            pstate = 0 as libc::c_int;\n            spaces = 0 as libc::c_int as size_t;\n            quoted = spaces as libc::c_int;\n            entry_pos = quoted as size_t;\n        }\n        _ => {}\n    }\n    (*p).status = 0 as libc::c_int;\n    (*p).entry_pos = (*p).status as size_t;\n    (*p).quoted = (*p).entry_pos as libc::c_int;\n    (*p).spaces = (*p).quoted as size_t;\n    (*p).pstate = 0 as libc::c_int;\n    return 0 as libc::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/main.rs:19:1: 19:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/main.rs:23:1: 23:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/main.rs:27:1: 27:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/main.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/main.rs:21:15: 21:19 (#0)",
        "source": "self"
      },
      {
        "span": "src/main.rs:25:1: 25:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/main.rs:21:1: 21:28 (#0)",
        "source": "use std::io::{self, Write};"
      },
      {
        "span": "src/main.rs:21:21: 21:26 (#0)",
        "source": "Write"
      },
      {
        "span": "src/main.rs:30:1: 30:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:49 ~ oxidate_out[187d]::csv_get_buffer_size)",
    "span": "src/main.rs:331:1: 336:2 (#0)",
    "pieces": [
      "src/main.rs:331:1: 336:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 6,
    "source": "pub unsafe extern \"C\" fn csv_get_buffer_size(mut p: *const csv_parser) -> size_t {\n    if !p.is_null() {\n        return (*p).entry_size;\n    }\n    return 0 as libc::c_int as size_t;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/main.rs:21:21: 21:26 (#0)",
        "source": "Write"
      },
      {
        "span": "src/main.rs:19:1: 19:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/main.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/main.rs:27:1: 27:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/main.rs:21:15: 21:19 (#0)",
        "source": "self"
      },
      {
        "span": "src/main.rs:21:1: 21:28 (#0)",
        "source": "use std::io::{self, Write};"
      },
      {
        "span": "src/main.rs:23:1: 23:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/main.rs:25:1: 25:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/main.rs:30:1: 30:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:50 ~ oxidate_out[187d]::csv_increase_buffer)",
    "span": "src/main.rs:338:1: 377:2 (#0)",
    "pieces": [
      "src/main.rs:338:1: 377:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 40,
    "source": "unsafe extern \"C\" fn csv_increase_buffer(mut p: *mut csv_parser) -> libc::c_int {\n    if p.is_null() {\n        return 0 as libc::c_int;\n    }\n    if ((*p).realloc_func).is_none() {\n        return 0 as libc::c_int;\n    }\n    let mut to_add = (*p).blk_size;\n    let mut vp = 0 as *mut libc::c_void;\n    if (*p).entry_size >= (18446744073709551615 as libc::c_ulong).wrapping_sub(to_add) {\n        to_add = (18446744073709551615 as libc::c_ulong).wrapping_sub((*p).entry_size);\n    }\n    if to_add == 0 {\n        (*p).status = 3 as libc::c_int;\n        return -(1 as libc::c_int);\n    }\n    loop {\n        vp = ((*p).realloc_func)\n            .expect(\n                \"non-null function pointer\",\n            )(\n            (*p).entry_buf as *mut libc::c_void,\n            ((*p).entry_size).wrapping_add(to_add),\n        );\n        if !vp.is_null() {\n            break;\n        }\n        to_add = (to_add as libc::c_ulong)\n            .wrapping_div(2 as libc::c_int as libc::c_ulong) as size_t as size_t;\n        if to_add == 0 {\n            (*p).status = 2 as libc::c_int;\n            return -(1 as libc::c_int);\n        }\n    }\n    (*p).entry_buf = vp as *mut libc::c_uchar;\n    (*p)\n        .entry_size = ((*p).entry_size as libc::c_ulong).wrapping_add(to_add) as size_t\n        as size_t;\n    return 0 as libc::c_int;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/main.rs:19:1: 19:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/main.rs:23:1: 23:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/main.rs:25:1: 25:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/main.rs:27:1: 27:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/main.rs:21:1: 21:28 (#0)",
        "source": "use std::io::{self, Write};"
      },
      {
        "span": "src/main.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/main.rs:21:21: 21:26 (#0)",
        "source": "Write"
      },
      {
        "span": "src/main.rs:21:15: 21:19 (#0)",
        "source": "self"
      },
      {
        "span": "src/main.rs:30:1: 30:12 (#0)",
        "source": "use ::libc;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:30 ~ oxidate_out[187d]::csv_free)",
    "span": "src/main.rs:171:1: 183:2 (#0)",
    "pieces": [
      "src/main.rs:171:1: 183:2 (#0)"
    ],
    "sub_chunks": [],
    "num_lines": 11,
    "source": "pub unsafe extern \"C\" fn csv_free(mut p: *mut csv_parser) {\n    if p.is_null() {\n        return;\n    }\n    if !((*p).entry_buf).is_null() && ((*p).free_func).is_some() {\n        ((*p).free_func)\n            .expect(\"non-null function pointer\")((*p).entry_buf as *mut libc::c_void);\n    }\n    (*p).entry_buf = 0 as *mut libc::c_uchar;\n    (*p).entry_size = 0 as libc::c_int as size_t;\n}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/main.rs:21:15: 21:19 (#0)",
        "source": "self"
      },
      {
        "span": "src/main.rs:21:1: 21:28 (#0)",
        "source": "use std::io::{self, Write};"
      },
      {
        "span": "src/main.rs:21:21: 21:26 (#0)",
        "source": "Write"
      },
      {
        "span": "src/main.rs:27:1: 27:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/main.rs:30:1: 30:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/main.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/main.rs:23:1: 23:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/main.rs:25:1: 25:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/main.rs:19:1: 19:14 (#0)",
        "source": "use std::mem;"
      }
    ],
    "chunks": []
  },
  {
    "func_defid": "DefId(0:51 ~ oxidate_out[187d]::csv_parse)",
    "span": "src/main.rs:379:1: 830:2 (#0)",
    "pieces": [
      "src/main.rs:379:1: 389:4 (#0)",
      "src/main.rs:830:1: 830:2 (#0)"
    ],
    "sub_chunks": [
      4
    ],
    "num_lines": 12,
    "source": "pub unsafe extern \"C\" fn csv_parse(\n    mut p: *mut csv_parser,\n    mut s: *const libc::c_void,\n    mut len: size_t,\n    mut cb1: Option::<\n        unsafe extern \"C\" fn(*mut libc::c_void, size_t, *mut libc::c_void) -> (),\n    >,\n    mut cb2: Option::<unsafe extern \"C\" fn(libc::c_int, *mut libc::c_void) -> ()>,\n    mut data: *mut libc::c_void,\n) -> size_t {\n   <<chunk 4>>}",
    "calls": [],
    "globals": [],
    "imports": [
      {
        "span": "src/main.rs:27:1: 27:16 (#0)",
        "source": "use std::slice;"
      },
      {
        "span": "src/main.rs:25:1: 25:26 (#0)",
        "source": "use std::os::raw::c_void;"
      },
      {
        "span": "src/main.rs:19:1: 19:14 (#0)",
        "source": "use std::mem;"
      },
      {
        "span": "src/main.rs:30:1: 30:12 (#0)",
        "source": "use ::libc;"
      },
      {
        "span": "src/main.rs:21:1: 21:28 (#0)",
        "source": "use std::io::{self, Write};"
      },
      {
        "span": "src/main.rs:23:1: 23:24 (#0)",
        "source": "use std::ptr::null_mut;"
      },
      {
        "span": "src/main.rs:21:21: 21:26 (#0)",
        "source": "Write"
      },
      {
        "span": "src/main.rs:28:1: 28:27 (#0)",
        "source": "use std::convert::TryInto;"
      },
      {
        "span": "src/main.rs:21:15: 21:19 (#0)",
        "source": "self"
      }
    ],
    "chunks": [
      {
        "chunk_id": 0,
        "span": "src/main.rs:472:17: 574:18 (#0)",
        "pieces": [
          "src/main.rs:472:17: 574:18 (#0)"
        ],
        "num_lines": 103,
        "source": "if (if is_space.is_some() {\n                    is_space.expect(\"non-null function pointer\")(c)\n                } else {\n                    (c as libc::c_int == 0x20 as libc::c_int\n                        || c as libc::c_int == 0x9 as libc::c_int) as libc::c_int\n                }) != 0 && c as libc::c_int != delim as libc::c_int\n                {\n                    continue;\n                }\n                if if is_term.is_some() {\n                    is_term.expect(\"non-null function pointer\")(c)\n                } else {\n                    (c as libc::c_int == 0xd as libc::c_int\n                        || c as libc::c_int == 0xa as libc::c_int) as libc::c_int\n                } != 0\n                {\n                    if pstate == 1 as libc::c_int {\n                        if quoted == 0 {\n                            entry_pos = (entry_pos as libc::c_ulong).wrapping_sub(spaces)\n                                as size_t as size_t;\n                        }\n                        if (*p).options as libc::c_int & 8 as libc::c_int != 0 {\n                            *((*p).entry_buf)\n                                .offset(entry_pos as isize) = '\\0' as i32 as libc::c_uchar;\n                        }\n                        if cb1.is_some()\n                            && (*p).options as libc::c_int & 16 as libc::c_int != 0\n                            && quoted == 0\n                            && entry_pos == 0 as libc::c_int as libc::c_ulong\n                        {\n                            cb1\n                                .expect(\n                                    \"non-null function pointer\",\n                                )(0 as *mut libc::c_void, entry_pos, data);\n                        } else if cb1.is_some() {\n                            cb1\n                                .expect(\n                                    \"non-null function pointer\",\n                                )((*p).entry_buf as *mut libc::c_void, entry_pos, data);\n                        }\n                        pstate = 1 as libc::c_int;\n                        spaces = 0 as libc::c_int as size_t;\n                        quoted = spaces as libc::c_int;\n                        entry_pos = quoted as size_t;\n                        if cb2.is_some() {\n                            cb2\n                                .expect(\n                                    \"non-null function pointer\",\n                                )(c as libc::c_int, data);\n                        }\n                        pstate = 0 as libc::c_int;\n                        spaces = 0 as libc::c_int as size_t;\n                        quoted = spaces as libc::c_int;\n                        entry_pos = quoted as size_t;\n                    } else if (*p).options as libc::c_int & 2 as libc::c_int != 0 {\n                        if cb2.is_some() {\n                            cb2\n                                .expect(\n                                    \"non-null function pointer\",\n                                )(c as libc::c_int, data);\n                        }\n                        pstate = 0 as libc::c_int;\n                        spaces = 0 as libc::c_int as size_t;\n                        quoted = spaces as libc::c_int;\n                        entry_pos = quoted as size_t;\n                    }\n                } else if c as libc::c_int == delim as libc::c_int {\n                    if quoted == 0 {\n                        entry_pos = (entry_pos as libc::c_ulong).wrapping_sub(spaces)\n                            as size_t as size_t;\n                    }\n                    if (*p).options as libc::c_int & 8 as libc::c_int != 0 {\n                        *((*p).entry_buf)\n                            .offset(entry_pos as isize) = '\\0' as i32 as libc::c_uchar;\n                    }\n                    if cb1.is_some()\n                        && (*p).options as libc::c_int & 16 as libc::c_int != 0\n                        && quoted == 0 && entry_pos == 0 as libc::c_int as libc::c_ulong\n                    {\n                        cb1\n                            .expect(\n                                \"non-null function pointer\",\n                            )(0 as *mut libc::c_void, entry_pos, data);\n                    } else if cb1.is_some() {\n                        cb1\n                            .expect(\n                                \"non-null function pointer\",\n                            )((*p).entry_buf as *mut libc::c_void, entry_pos, data);\n                    }\n                    pstate = 1 as libc::c_int;\n                    spaces = 0 as libc::c_int as size_t;\n                    quoted = spaces as libc::c_int;\n                    entry_pos = quoted as size_t;\n                } else if c as libc::c_int == quote as libc::c_int {\n                    pstate = 2 as libc::c_int;\n                    quoted = 1 as libc::c_int;\n                } else {\n                    pstate = 2 as libc::c_int;\n                    quoted = 0 as libc::c_int;\n                    let fresh1 = entry_pos;\n                    entry_pos = entry_pos.wrapping_add(1);\n                    *((*p).entry_buf).offset(fresh1 as isize) = c;\n                }",
        "sub_chunks": [],
        "live_in": [
          "mut p: *mut csv_parser",
          "mut cb1: std::option::Option<unsafe extern \"C\" fn(*mut libc::c_void, u64, *mut libc::c_void)>",
          "mut cb2: std::option::Option<unsafe extern \"C\" fn(i32, *mut libc::c_void)>",
          "mut data: *mut libc::c_void",
          "mut c: u8",
          "mut delim: u8",
          "mut quote: u8",
          "mut is_space: std::option::Option<unsafe extern \"C\" fn(u8) -> i32>",
          "mut is_term: std::option::Option<unsafe extern \"C\" fn(u8) -> i32>",
          "mut quoted: i32",
          "mut pstate: i32",
          "mut spaces: u64",
          "mut entry_pos: u64"
        ],
        "live_out": [
          "mut p: *mut csv_parser",
          "mut cb1: std::option::Option<unsafe extern \"C\" fn(*mut libc::c_void, u64, *mut libc::c_void)>",
          "mut cb2: std::option::Option<unsafe extern \"C\" fn(i32, *mut libc::c_void)>",
          "mut data: *mut libc::c_void",
          "mut c: u8",
          "mut delim: u8",
          "mut quote: u8",
          "mut is_space: std::option::Option<unsafe extern \"C\" fn(u8) -> i32>",
          "mut is_term: std::option::Option<unsafe extern \"C\" fn(u8) -> i32>",
          "mut quoted: i32",
          "mut pstate: i32",
          "mut spaces: u64",
          "mut entry_pos: u64"
        ]
      },
      {
        "chunk_id": 1,
        "span": "src/main.rs:577:17: 699:18 (#0)",
        "pieces": [
          "src/main.rs:577:17: 699:18 (#0)"
        ],
        "num_lines": 123,
        "source": "if c as libc::c_int == quote as libc::c_int {\n                    if quoted != 0 {\n                        let fresh2 = entry_pos;\n                        entry_pos = entry_pos.wrapping_add(1);\n                        *((*p).entry_buf).offset(fresh2 as isize) = c;\n                        pstate = 3 as libc::c_int;\n                    } else {\n                        if (*p).options as libc::c_int & 1 as libc::c_int != 0 {\n                            (*p).status = 1 as libc::c_int;\n                            (*p).quoted = quoted;\n                            (*p).pstate = pstate;\n                            (*p).spaces = spaces;\n                            (*p).entry_pos = entry_pos;\n                            return pos.wrapping_sub(1 as libc::c_int as libc::c_ulong);\n                        }\n                        let fresh3 = entry_pos;\n                        entry_pos = entry_pos.wrapping_add(1);\n                        *((*p).entry_buf).offset(fresh3 as isize) = c;\n                        spaces = 0 as libc::c_int as size_t;\n                    }\n                } else if c as libc::c_int == delim as libc::c_int {\n                    if quoted != 0 {\n                        let fresh4 = entry_pos;\n                        entry_pos = entry_pos.wrapping_add(1);\n                        *((*p).entry_buf).offset(fresh4 as isize) = c;\n                    } else {\n                        if quoted == 0 {\n                            entry_pos = (entry_pos as libc::c_ulong).wrapping_sub(spaces)\n                                as size_t as size_t;\n                        }\n                        if (*p).options as libc::c_int & 8 as libc::c_int != 0 {\n                            *((*p).entry_buf)\n                                .offset(entry_pos as isize) = '\\0' as i32 as libc::c_uchar;\n                        }\n                        if cb1.is_some()\n                            && (*p).options as libc::c_int & 16 as libc::c_int != 0\n                            && quoted == 0\n                            && entry_pos == 0 as libc::c_int as libc::c_ulong\n                        {\n                            cb1\n                                .expect(\n                                    \"non-null function pointer\",\n                                )(0 as *mut libc::c_void, entry_pos, data);\n                        } else if cb1.is_some() {\n                            cb1\n                                .expect(\n                                    \"non-null function pointer\",\n                                )((*p).entry_buf as *mut libc::c_void, entry_pos, data);\n                        }\n                        pstate = 1 as libc::c_int;\n                        spaces = 0 as libc::c_int as size_t;\n                        quoted = spaces as libc::c_int;\n                        entry_pos = quoted as size_t;\n                    }\n                } else if if is_term.is_some() {\n                    is_term.expect(\"non-null function pointer\")(c)\n                } else {\n                    (c as libc::c_int == 0xd as libc::c_int\n                        || c as libc::c_int == 0xa as libc::c_int) as libc::c_int\n                } != 0\n                {\n                    if quoted == 0 {\n                        if quoted == 0 {\n                            entry_pos = (entry_pos as libc::c_ulong).wrapping_sub(spaces)\n                                as size_t as size_t;\n                        }\n                        if (*p).options as libc::c_int & 8 as libc::c_int != 0 {\n                            *((*p).entry_buf)\n                                .offset(entry_pos as isize) = '\\0' as i32 as libc::c_uchar;\n                        }\n                        if cb1.is_some()\n                            && (*p).options as libc::c_int & 16 as libc::c_int != 0\n                            && quoted == 0\n                            && entry_pos == 0 as libc::c_int as libc::c_ulong\n                        {\n                            cb1\n                                .expect(\n                                    \"non-null function pointer\",\n                                )(0 as *mut libc::c_void, entry_pos, data);\n                        } else if cb1.is_some() {\n                            cb1\n                                .expect(\n                                    \"non-null function pointer\",\n                                )((*p).entry_buf as *mut libc::c_void, entry_pos, data);\n                        }\n                        pstate = 1 as libc::c_int;\n                        spaces = 0 as libc::c_int as size_t;\n                        quoted = spaces as libc::c_int;\n                        entry_pos = quoted as size_t;\n                        if cb2.is_some() {\n                            cb2\n                                .expect(\n                                    \"non-null function pointer\",\n                                )(c as libc::c_int, data);\n                        }\n                        pstate = 0 as libc::c_int;\n                        spaces = 0 as libc::c_int as size_t;\n                        quoted = spaces as libc::c_int;\n                        entry_pos = quoted as size_t;\n                    } else {\n                        let fresh5 = entry_pos;\n                        entry_pos = entry_pos.wrapping_add(1);\n                        *((*p).entry_buf).offset(fresh5 as isize) = c;\n                    }\n                } else if quoted == 0\n                    && (if is_space.is_some() {\n                        is_space.expect(\"non-null function pointer\")(c)\n                    } else {\n                        (c as libc::c_int == 0x20 as libc::c_int\n                            || c as libc::c_int == 0x9 as libc::c_int) as libc::c_int\n                    }) != 0\n                {\n                    let fresh6 = entry_pos;\n                    entry_pos = entry_pos.wrapping_add(1);\n                    *((*p).entry_buf).offset(fresh6 as isize) = c;\n                    spaces = spaces.wrapping_add(1);\n                    spaces;\n                } else {\n                    let fresh7 = entry_pos;\n                    entry_pos = entry_pos.wrapping_add(1);\n                    *((*p).entry_buf).offset(fresh7 as isize) = c;\n                    spaces = 0 as libc::c_int as size_t;\n                }",
        "sub_chunks": [],
        "live_in": [
          "mut p: *mut csv_parser",
          "mut cb1: std::option::Option<unsafe extern \"C\" fn(*mut libc::c_void, u64, *mut libc::c_void)>",
          "mut cb2: std::option::Option<unsafe extern \"C\" fn(i32, *mut libc::c_void)>",
          "mut data: *mut libc::c_void",
          "mut c: u8",
          "mut pos: u64",
          "mut delim: u8",
          "mut quote: u8",
          "mut is_space: std::option::Option<unsafe extern \"C\" fn(u8) -> i32>",
          "mut is_term: std::option::Option<unsafe extern \"C\" fn(u8) -> i32>",
          "mut quoted: i32",
          "mut pstate: i32",
          "mut spaces: u64",
          "mut entry_pos: u64"
        ],
        "live_out": [
          "mut p: *mut csv_parser",
          "mut cb1: std::option::Option<unsafe extern \"C\" fn(*mut libc::c_void, u64, *mut libc::c_void)>",
          "mut cb2: std::option::Option<unsafe extern \"C\" fn(i32, *mut libc::c_void)>",
          "mut data: *mut libc::c_void",
          "mut c: u8",
          "mut pos: u64",
          "mut delim: u8",
          "mut quote: u8",
          "mut is_space: std::option::Option<unsafe extern \"C\" fn(u8) -> i32>",
          "mut is_term: std::option::Option<unsafe extern \"C\" fn(u8) -> i32>",
          "mut quoted: i32",
          "mut pstate: i32",
          "mut spaces: u64",
          "mut entry_pos: u64"
        ]
      },
      {
        "chunk_id": 2,
        "span": "src/main.rs:702:17: 820:18 (#0)",
        "pieces": [
          "src/main.rs:702:17: 820:18 (#0)"
        ],
        "num_lines": 119,
        "source": "if c as libc::c_int == delim as libc::c_int {\n                    entry_pos = (entry_pos as libc::c_ulong)\n                        .wrapping_sub(\n                            spaces.wrapping_add(1 as libc::c_int as libc::c_ulong),\n                        ) as size_t as size_t;\n                    if quoted == 0 {\n                        entry_pos = (entry_pos as libc::c_ulong).wrapping_sub(spaces)\n                            as size_t as size_t;\n                    }\n                    if (*p).options as libc::c_int & 8 as libc::c_int != 0 {\n                        *((*p).entry_buf)\n                            .offset(entry_pos as isize) = '\\0' as i32 as libc::c_uchar;\n                    }\n                    if cb1.is_some()\n                        && (*p).options as libc::c_int & 16 as libc::c_int != 0\n                        && quoted == 0 && entry_pos == 0 as libc::c_int as libc::c_ulong\n                    {\n                        cb1\n                            .expect(\n                                \"non-null function pointer\",\n                            )(0 as *mut libc::c_void, entry_pos, data);\n                    } else if cb1.is_some() {\n                        cb1\n                            .expect(\n                                \"non-null function pointer\",\n                            )((*p).entry_buf as *mut libc::c_void, entry_pos, data);\n                    }\n                    pstate = 1 as libc::c_int;\n                    spaces = 0 as libc::c_int as size_t;\n                    quoted = spaces as libc::c_int;\n                    entry_pos = quoted as size_t;\n                } else if if is_term.is_some() {\n                    is_term.expect(\"non-null function pointer\")(c)\n                } else {\n                    (c as libc::c_int == 0xd as libc::c_int\n                        || c as libc::c_int == 0xa as libc::c_int) as libc::c_int\n                } != 0\n                {\n                    entry_pos = (entry_pos as libc::c_ulong)\n                        .wrapping_sub(\n                            spaces.wrapping_add(1 as libc::c_int as libc::c_ulong),\n                        ) as size_t as size_t;\n                    if quoted == 0 {\n                        entry_pos = (entry_pos as libc::c_ulong).wrapping_sub(spaces)\n                            as size_t as size_t;\n                    }\n                    if (*p).options as libc::c_int & 8 as libc::c_int != 0 {\n                        *((*p).entry_buf)\n                            .offset(entry_pos as isize) = '\\0' as i32 as libc::c_uchar;\n                    }\n                    if cb1.is_some()\n                        && (*p).options as libc::c_int & 16 as libc::c_int != 0\n                        && quoted == 0 && entry_pos == 0 as libc::c_int as libc::c_ulong\n                    {\n                        cb1\n                            .expect(\n                                \"non-null function pointer\",\n                            )(0 as *mut libc::c_void, entry_pos, data);\n                    } else if cb1.is_some() {\n                        cb1\n                            .expect(\n                                \"non-null function pointer\",\n                            )((*p).entry_buf as *mut libc::c_void, entry_pos, data);\n                    }\n                    pstate = 1 as libc::c_int;\n                    spaces = 0 as libc::c_int as size_t;\n                    quoted = spaces as libc::c_int;\n                    entry_pos = quoted as size_t;\n                    if cb2.is_some() {\n                        cb2.expect(\"non-null function pointer\")(c as libc::c_int, data);\n                    }\n                    pstate = 0 as libc::c_int;\n                    spaces = 0 as libc::c_int as size_t;\n                    quoted = spaces as libc::c_int;\n                    entry_pos = quoted as size_t;\n                } else if if is_space.is_some() {\n                    is_space.expect(\"non-null function pointer\")(c)\n                } else {\n                    (c as libc::c_int == 0x20 as libc::c_int\n                        || c as libc::c_int == 0x9 as libc::c_int) as libc::c_int\n                } != 0\n                {\n                    let fresh8 = entry_pos;\n                    entry_pos = entry_pos.wrapping_add(1);\n                    *((*p).entry_buf).offset(fresh8 as isize) = c;\n                    spaces = spaces.wrapping_add(1);\n                    spaces;\n                } else if c as libc::c_int == quote as libc::c_int {\n                    if spaces != 0 {\n                        if (*p).options as libc::c_int & 1 as libc::c_int != 0 {\n                            (*p).status = 1 as libc::c_int;\n                            (*p).quoted = quoted;\n                            (*p).pstate = pstate;\n                            (*p).spaces = spaces;\n                            (*p).entry_pos = entry_pos;\n                            return pos.wrapping_sub(1 as libc::c_int as libc::c_ulong);\n                        }\n                        spaces = 0 as libc::c_int as size_t;\n                        let fresh9 = entry_pos;\n                        entry_pos = entry_pos.wrapping_add(1);\n                        *((*p).entry_buf).offset(fresh9 as isize) = c;\n                    } else {\n                        pstate = 2 as libc::c_int;\n                    }\n                } else {\n                    if (*p).options as libc::c_int & 1 as libc::c_int != 0 {\n                        (*p).status = 1 as libc::c_int;\n                        (*p).quoted = quoted;\n                        (*p).pstate = pstate;\n                        (*p).spaces = spaces;\n                        (*p).entry_pos = entry_pos;\n                        return pos.wrapping_sub(1 as libc::c_int as libc::c_ulong);\n                    }\n                    pstate = 2 as libc::c_int;\n                    spaces = 0 as libc::c_int as size_t;\n                    let fresh10 = entry_pos;\n                    entry_pos = entry_pos.wrapping_add(1);\n                    *((*p).entry_buf).offset(fresh10 as isize) = c;\n                }",
        "sub_chunks": [],
        "live_in": [
          "mut p: *mut csv_parser",
          "mut cb1: std::option::Option<unsafe extern \"C\" fn(*mut libc::c_void, u64, *mut libc::c_void)>",
          "mut cb2: std::option::Option<unsafe extern \"C\" fn(i32, *mut libc::c_void)>",
          "mut data: *mut libc::c_void",
          "mut c: u8",
          "mut pos: u64",
          "mut delim: u8",
          "mut quote: u8",
          "mut is_space: std::option::Option<unsafe extern \"C\" fn(u8) -> i32>",
          "mut is_term: std::option::Option<unsafe extern \"C\" fn(u8) -> i32>",
          "mut quoted: i32",
          "mut pstate: i32",
          "mut spaces: u64",
          "mut entry_pos: u64"
        ],
        "live_out": [
          "mut p: *mut csv_parser",
          "mut cb1: std::option::Option<unsafe extern \"C\" fn(*mut libc::c_void, u64, *mut libc::c_void)>",
          "mut cb2: std::option::Option<unsafe extern \"C\" fn(i32, *mut libc::c_void)>",
          "mut data: *mut libc::c_void",
          "mut c: u8",
          "mut pos: u64",
          "mut delim: u8",
          "mut quote: u8",
          "mut is_space: std::option::Option<unsafe extern \"C\" fn(u8) -> i32>",
          "mut is_term: std::option::Option<unsafe extern \"C\" fn(u8) -> i32>",
          "mut quoted: i32",
          "mut pstate: i32",
          "mut spaces: u64",
          "mut entry_pos: u64"
        ]
      },
      {
        "chunk_id": 3,
        "span": "src/main.rs:452:9: 823:10 (#0)",
        "pieces": [
          "src/main.rs:452:9: 472:16 (#0)",
          "src/main.rs:575:1: 577:16 (#0)",
          "src/main.rs:700:1: 702:16 (#0)",
          "src/main.rs:821:1: 823:10 (#0)"
        ],
        "num_lines": 30,
        "source": "if entry_pos\n            == (if (*p).options as libc::c_int & 8 as libc::c_int != 0 {\n                ((*p).entry_size).wrapping_sub(1 as libc::c_int as libc::c_ulong)\n            } else {\n                (*p).entry_size\n            })\n        {\n            if csv_increase_buffer(p) != 0 as libc::c_int {\n                (*p).quoted = quoted;\n                (*p).pstate = pstate;\n                (*p).spaces = spaces;\n                (*p).entry_pos = entry_pos;\n                return pos;\n            }\n        }\n        let fresh0 = pos;\n        pos = pos.wrapping_add(1);\n        c = *us.offset(fresh0 as isize);\n        match pstate {\n            0 | 1 => {\n               <<chunk 0>>            }\n            2 => {\n               <<chunk 1>>            }\n            3 => {\n               <<chunk 2>>            }\n            _ => {}\n        }",
        "sub_chunks": [
          0,
          1,
          2
        ],
        "live_in": [
          "mut p: *mut csv_parser",
          "mut cb1: std::option::Option<unsafe extern \"C\" fn(*mut libc::c_void, u64, *mut libc::c_void)>",
          "mut cb2: std::option::Option<unsafe extern \"C\" fn(i32, *mut libc::c_void)>",
          "mut data: *mut libc::c_void",
          "mut us: *const u8",
          "mut c: u8",
          "mut pos: u64",
          "mut delim: u8",
          "mut quote: u8",
          "mut is_space: std::option::Option<unsafe extern \"C\" fn(u8) -> i32>",
          "mut is_term: std::option::Option<unsafe extern \"C\" fn(u8) -> i32>",
          "mut quoted: i32",
          "mut pstate: i32",
          "mut spaces: u64",
          "mut entry_pos: u64"
        ],
        "live_out": [
          "mut p: *mut csv_parser",
          "mut cb1: std::option::Option<unsafe extern \"C\" fn(*mut libc::c_void, u64, *mut libc::c_void)>",
          "mut cb2: std::option::Option<unsafe extern \"C\" fn(i32, *mut libc::c_void)>",
          "mut data: *mut libc::c_void",
          "mut us: *const u8",
          "mut c: u8",
          "mut pos: u64",
          "mut delim: u8",
          "mut quote: u8",
          "mut is_space: std::option::Option<unsafe extern \"C\" fn(u8) -> i32>",
          "mut is_term: std::option::Option<unsafe extern \"C\" fn(u8) -> i32>",
          "mut quoted: i32",
          "mut pstate: i32",
          "mut spaces: u64",
          "mut entry_pos: u64",
          "fresh0: u64"
        ]
      },
      {
        "chunk_id": 4,
        "span": "src/main.rs:389:5: 829:16 (#0)",
        "pieces": [
          "src/main.rs:389:5: 452:8 (#0)",
          "src/main.rs:824:1: 829:16 (#0)"
        ],
        "num_lines": 70,
        "source": "if !p.is_null()\n        && !(b\"received null csv_parser\\0\" as *const u8 as *const libc::c_char).is_null()\n    {} else {\n        __assert_fail(\n            b\"p && \\\"received null csv_parser\\\"\\0\" as *const u8 as *const libc::c_char,\n            b\"/workspace/programs/libcsv/libcsv.c\\0\" as *const u8 as *const libc::c_char,\n            321 as libc::c_int as libc::c_uint,\n            (*::core::mem::transmute::<\n                &[u8; 125],\n                &[libc::c_char; 125],\n            >(\n                b\"size_t csv_parse(struct csv_parser *, const void *, size_t, void (*)(void *, size_t, void *), void (*)(int, void *), void *)\\0\",\n            ))\n                .as_ptr(),\n        );\n    }\n    'c_3814: {\n        if !p.is_null()\n            && !(b\"received null csv_parser\\0\" as *const u8 as *const libc::c_char)\n                .is_null()\n        {} else {\n            __assert_fail(\n                b\"p && \\\"received null csv_parser\\\"\\0\" as *const u8\n                    as *const libc::c_char,\n                b\"/workspace/programs/libcsv/libcsv.c\\0\" as *const u8\n                    as *const libc::c_char,\n                321 as libc::c_int as libc::c_uint,\n                (*::core::mem::transmute::<\n                    &[u8; 125],\n                    &[libc::c_char; 125],\n                >(\n                    b\"size_t csv_parse(struct csv_parser *, const void *, size_t, void (*)(void *, size_t, void *), void (*)(int, void *), void *)\\0\",\n                ))\n                    .as_ptr(),\n            );\n        }\n    };\n    if s.is_null() {\n        return 0 as libc::c_int as size_t;\n    }\n    let mut us = s as *const libc::c_uchar;\n    let mut c: libc::c_uchar = 0;\n    let mut pos = 0 as libc::c_int as size_t;\n    let mut delim = (*p).delim_char;\n    let mut quote = (*p).quote_char;\n    let mut is_space: Option::<unsafe extern \"C\" fn(libc::c_uchar) -> libc::c_int> = (*p)\n        .is_space;\n    let mut is_term: Option::<unsafe extern \"C\" fn(libc::c_uchar) -> libc::c_int> = (*p)\n        .is_term;\n    let mut quoted = (*p).quoted;\n    let mut pstate = (*p).pstate;\n    let mut spaces = (*p).spaces;\n    let mut entry_pos = (*p).entry_pos;\n    if ((*p).entry_buf).is_null() && pos < len {\n        if csv_increase_buffer(p) != 0 as libc::c_int {\n            (*p).quoted = quoted;\n            (*p).pstate = pstate;\n            (*p).spaces = spaces;\n            (*p).entry_pos = entry_pos;\n            return pos;\n        }\n    }\n    while pos < len {\n       <<chunk 3>>    }\n    (*p).quoted = quoted;\n    (*p).pstate = pstate;\n    (*p).spaces = spaces;\n    (*p).entry_pos = entry_pos;\n    return pos;",
        "sub_chunks": [
          3
        ],
        "live_in": [
          "mut p: *mut csv_parser",
          "mut s: *const libc::c_void",
          "mut len: u64",
          "mut cb1: std::option::Option<unsafe extern \"C\" fn(*mut libc::c_void, u64, *mut libc::c_void)>",
          "mut cb2: std::option::Option<unsafe extern \"C\" fn(i32, *mut libc::c_void)>",
          "mut data: *mut libc::c_void"
        ],
        "live_out": [
          "mut p: *mut csv_parser",
          "mut s: *const libc::c_void",
          "mut len: u64",
          "mut cb1: std::option::Option<unsafe extern \"C\" fn(*mut libc::c_void, u64, *mut libc::c_void)>",
          "mut cb2: std::option::Option<unsafe extern \"C\" fn(i32, *mut libc::c_void)>",
          "mut data: *mut libc::c_void",
          "mut us: *const u8",
          "mut c: u8",
          "mut pos: u64",
          "mut delim: u8",
          "mut quote: u8",
          "mut is_space: std::option::Option<unsafe extern \"C\" fn(u8) -> i32>",
          "mut is_term: std::option::Option<unsafe extern \"C\" fn(u8) -> i32>",
          "mut quoted: i32",
          "mut pstate: i32",
          "mut spaces: u64",
          "mut entry_pos: u64"
        ]
      }
    ]
  }
]